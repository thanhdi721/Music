{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _excluded = [\"name\"];\nimport { merge } from \"rc-util/es/utils/set\";\nimport warning from \"rc-util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"./FieldContext\";\nimport { allPromiseFinish } from \"./utils/asyncUtil\";\nimport { defaultValidateMessages } from \"./utils/messages\";\nimport NameMap from \"./utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"./utils/valueUtil\";\nexport var FormStore = /*#__PURE__*/_createClass(function FormStore(forceRootUpdate) {\n  var _this = this;\n\n  _classCallCheck(this, FormStore);\n\n  _defineProperty(this, \"formHooked\", false);\n\n  _defineProperty(this, \"forceRootUpdate\", void 0);\n\n  _defineProperty(this, \"subscribable\", true);\n\n  _defineProperty(this, \"store\", {});\n\n  _defineProperty(this, \"fieldEntities\", []);\n\n  _defineProperty(this, \"initialValues\", {});\n\n  _defineProperty(this, \"callbacks\", {});\n\n  _defineProperty(this, \"validateMessages\", null);\n\n  _defineProperty(this, \"preserve\", null);\n\n  _defineProperty(this, \"lastValidatePromise\", null);\n\n  _defineProperty(this, \"getForm\", function () {\n    return {\n      getFieldValue: _this.getFieldValue,\n      getFieldsValue: _this.getFieldsValue,\n      getFieldError: _this.getFieldError,\n      getFieldWarning: _this.getFieldWarning,\n      getFieldsError: _this.getFieldsError,\n      isFieldsTouched: _this.isFieldsTouched,\n      isFieldTouched: _this.isFieldTouched,\n      isFieldValidating: _this.isFieldValidating,\n      isFieldsValidating: _this.isFieldsValidating,\n      resetFields: _this.resetFields,\n      setFields: _this.setFields,\n      setFieldValue: _this.setFieldValue,\n      setFieldsValue: _this.setFieldsValue,\n      validateFields: _this.validateFields,\n      submit: _this.submit,\n      _init: true,\n      getInternalHooks: _this.getInternalHooks\n    };\n  }); // ======================== Internal Hooks ========================\n\n\n  _defineProperty(this, \"getInternalHooks\", function (key) {\n    if (key === HOOK_MARK) {\n      _this.formHooked = true;\n      return {\n        dispatch: _this.dispatch,\n        initEntityValue: _this.initEntityValue,\n        registerField: _this.registerField,\n        useSubscribe: _this.useSubscribe,\n        setInitialValues: _this.setInitialValues,\n        destroyForm: _this.destroyForm,\n        setCallbacks: _this.setCallbacks,\n        setValidateMessages: _this.setValidateMessages,\n        getFields: _this.getFields,\n        setPreserve: _this.setPreserve,\n        getInitialValue: _this.getInitialValue,\n        registerWatch: _this.registerWatch\n      };\n    }\n\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  });\n\n  _defineProperty(this, \"useSubscribe\", function (subscribable) {\n    _this.subscribable = subscribable;\n  });\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n\n\n  _defineProperty(this, \"prevWithoutPreserves\", null);\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n\n\n  _defineProperty(this, \"setInitialValues\", function (initialValues, init) {\n    _this.initialValues = initialValues || {};\n\n    if (init) {\n      var _this$prevWithoutPres;\n\n      var nextStore = merge(initialValues, _this.store); // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n\n      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(function (_ref) {\n        var namePath = _ref.key;\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      _this.prevWithoutPreserves = null;\n\n      _this.updateStore(nextStore);\n    }\n  });\n\n  _defineProperty(this, \"destroyForm\", function () {\n    var prevWithoutPreserves = new NameMap();\n\n    _this.getFieldEntities(true).forEach(function (entity) {\n      if (!_this.isMergedPreserve(entity.isPreserve())) {\n        prevWithoutPreserves.set(entity.getNamePath(), true);\n      }\n    });\n\n    _this.prevWithoutPreserves = prevWithoutPreserves;\n  });\n\n  _defineProperty(this, \"getInitialValue\", function (namePath) {\n    var initValue = getValue(_this.initialValues, namePath); // Not cloneDeep when without `namePath`\n\n    return namePath.length ? merge(initValue) : initValue;\n  });\n\n  _defineProperty(this, \"setCallbacks\", function (callbacks) {\n    _this.callbacks = callbacks;\n  });\n\n  _defineProperty(this, \"setValidateMessages\", function (validateMessages) {\n    _this.validateMessages = validateMessages;\n  });\n\n  _defineProperty(this, \"setPreserve\", function (preserve) {\n    _this.preserve = preserve;\n  }); // ============================= Watch ============================\n\n\n  _defineProperty(this, \"watchList\", []);\n\n  _defineProperty(this, \"registerWatch\", function (callback) {\n    _this.watchList.push(callback);\n\n    return function () {\n      _this.watchList = _this.watchList.filter(function (fn) {\n        return fn !== callback;\n      });\n    };\n  });\n\n  _defineProperty(this, \"notifyWatch\", function () {\n    var namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // No need to cost perf when nothing need to watch\n\n    if (_this.watchList.length) {\n      var values = _this.getFieldsValue();\n\n      var allValues = _this.getFieldsValue(true);\n\n      _this.watchList.forEach(function (callback) {\n        callback(values, allValues, namePath);\n      });\n    }\n  }); // ========================== Dev Warning =========================\n\n\n  _defineProperty(this, \"timeoutId\", null);\n\n  _defineProperty(this, \"warningUnhooked\", function () {\n    if (process.env.NODE_ENV !== 'production' && !_this.timeoutId && typeof window !== 'undefined') {\n      _this.timeoutId = setTimeout(function () {\n        _this.timeoutId = null;\n\n        if (!_this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  }); // ============================ Store =============================\n\n\n  _defineProperty(this, \"updateStore\", function (nextStore) {\n    _this.store = nextStore;\n  }); // ============================ Fields ============================\n\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n\n\n  _defineProperty(this, \"getFieldEntities\", function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (!pure) {\n      return _this.fieldEntities;\n    }\n\n    return _this.fieldEntities.filter(function (field) {\n      return field.getNamePath().length;\n    });\n  });\n\n  _defineProperty(this, \"getFieldsMap\", function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cache = new NameMap();\n\n    _this.getFieldEntities(pure).forEach(function (field) {\n      var namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n\n    return cache;\n  });\n\n  _defineProperty(this, \"getFieldEntitiesForNamePathList\", function (nameList) {\n    if (!nameList) {\n      return _this.getFieldEntities(true);\n    }\n\n    var cache = _this.getFieldsMap(true);\n\n    return nameList.map(function (name) {\n      var namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  });\n\n  _defineProperty(this, \"getFieldsValue\", function (nameList, filterFunc) {\n    _this.warningUnhooked(); // Fill args\n\n\n    var mergedNameList;\n    var mergedFilterFunc;\n    var mergedStrict;\n\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && _typeof(nameList) === 'object') {\n      mergedStrict = nameList.strict;\n      mergedFilterFunc = nameList.filter;\n    }\n\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return _this.store;\n    }\n\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\n\n    var filteredNameList = [];\n    fieldEntities.forEach(function (entity) {\n      var _isListField, _ref3;\n\n      var namePath = 'INVALIDATE_NAME_PATH' in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath(); // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n\n      if (mergedStrict) {\n        var _isList, _ref2;\n\n        if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2)) {\n          return;\n        }\n      } else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3)) {\n        return;\n      }\n\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        var meta = 'getMeta' in entity ? entity.getMeta() : null;\n\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));\n  });\n\n  _defineProperty(this, \"getFieldValue\", function (name) {\n    _this.warningUnhooked();\n\n    var namePath = getNamePath(name);\n    return getValue(_this.store, namePath);\n  });\n\n  _defineProperty(this, \"getFieldsError\", function (nameList) {\n    _this.warningUnhooked();\n\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);\n\n    return fieldEntities.map(function (entity, index) {\n      if (entity && !('INVALIDATE_NAME_PATH' in entity)) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  });\n\n  _defineProperty(this, \"getFieldError\", function (name) {\n    _this.warningUnhooked();\n\n    var namePath = getNamePath(name);\n\n    var fieldError = _this.getFieldsError([namePath])[0];\n\n    return fieldError.errors;\n  });\n\n  _defineProperty(this, \"getFieldWarning\", function (name) {\n    _this.warningUnhooked();\n\n    var namePath = getNamePath(name);\n\n    var fieldError = _this.getFieldsError([namePath])[0];\n\n    return fieldError.warnings;\n  });\n\n  _defineProperty(this, \"isFieldsTouched\", function () {\n    _this.warningUnhooked();\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var arg0 = args[0],\n        arg1 = args[1];\n    var namePathList;\n    var isAllFieldsTouched = false;\n\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n\n    var fieldEntities = _this.getFieldEntities(true);\n\n    var isFieldTouched = function isFieldTouched(field) {\n      return field.isFieldTouched();\n    }; // ===== Will get fully compare when not config namePathList =====\n\n\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(function (entity) {\n        return isFieldTouched(entity) || entity.isList();\n      }) : fieldEntities.some(isFieldTouched);\n    } // Generate a nest tree for validate\n\n\n    var map = new NameMap();\n    namePathList.forEach(function (shortNamePath) {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(function (field) {\n      var fieldNamePath = field.getNamePath(); // Find matched entity and put into list\n\n      namePathList.forEach(function (shortNamePath) {\n        if (shortNamePath.every(function (nameUnit, i) {\n          return fieldNamePath[i] === nameUnit;\n        })) {\n          map.update(shortNamePath, function (list) {\n            return [].concat(_toConsumableArray(list), [field]);\n          });\n        }\n      });\n    }); // Check if NameMap value is touched\n\n    var isNamePathListTouched = function isNamePathListTouched(entities) {\n      return entities.some(isFieldTouched);\n    };\n\n    var namePathListEntities = map.map(function (_ref4) {\n      var value = _ref4.value;\n      return value;\n    });\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  });\n\n  _defineProperty(this, \"isFieldTouched\", function (name) {\n    _this.warningUnhooked();\n\n    return _this.isFieldsTouched([name]);\n  });\n\n  _defineProperty(this, \"isFieldsValidating\", function (nameList) {\n    _this.warningUnhooked();\n\n    var fieldEntities = _this.getFieldEntities();\n\n    if (!nameList) {\n      return fieldEntities.some(function (testField) {\n        return testField.isFieldValidating();\n      });\n    }\n\n    var namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(function (testField) {\n      var fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  });\n\n  _defineProperty(this, \"isFieldValidating\", function (name) {\n    _this.warningUnhooked();\n\n    return _this.isFieldsValidating([name]);\n  });\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n\n\n  _defineProperty(this, \"resetWithFieldInitialValue\", function () {\n    var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Create cache\n\n    var cache = new NameMap();\n\n    var fieldEntities = _this.getFieldEntities(true);\n\n    fieldEntities.forEach(function (field) {\n      var initialValue = field.props.initialValue;\n      var namePath = field.getNamePath(); // Record only if has `initialValue`\n\n      if (initialValue !== undefined) {\n        var records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    }); // Reset\n\n    var resetWithFields = function resetWithFields(entities) {\n      entities.forEach(function (field) {\n        var initialValue = field.props.initialValue;\n\n        if (initialValue !== undefined) {\n          var namePath = field.getNamePath();\n\n          var formInitialValue = _this.getInitialValue(namePath);\n\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, \"Form already set 'initialValues' with path '\".concat(namePath.join('.'), \"'. Field can not overwrite it.\"));\n          } else {\n            var records = cache.get(namePath);\n\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, \"Multiple Field with path '\".concat(namePath.join('.'), \"' set 'initialValue'. Can not decide which one to pick.\"));\n            } else if (records) {\n              var originValue = _this.getFieldValue(namePath);\n\n              var isListField = field.isListField(); // Set `initialValue`\n\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n\n    var requiredFieldEntities;\n\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(function (namePath) {\n        var records = cache.get(namePath);\n\n        if (records) {\n          var _requiredFieldEntitie;\n\n          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function (r) {\n            return r.entity;\n          })));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n\n    resetWithFields(requiredFieldEntities);\n  });\n\n  _defineProperty(this, \"resetFields\", function (nameList) {\n    _this.warningUnhooked();\n\n    var prevStore = _this.store;\n\n    if (!nameList) {\n      _this.updateStore(merge(_this.initialValues));\n\n      _this.resetWithFieldInitialValue();\n\n      _this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n\n      _this.notifyWatch();\n\n      return;\n    } // Reset by `nameList`\n\n\n    var namePathList = nameList.map(getNamePath);\n    namePathList.forEach(function (namePath) {\n      var initialValue = _this.getInitialValue(namePath);\n\n      _this.updateStore(setValue(_this.store, namePath, initialValue));\n    });\n\n    _this.resetWithFieldInitialValue({\n      namePathList: namePathList\n    });\n\n    _this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n\n    _this.notifyWatch(namePathList);\n  });\n\n  _defineProperty(this, \"setFields\", function (fields) {\n    _this.warningUnhooked();\n\n    var prevStore = _this.store;\n    var namePathList = [];\n    fields.forEach(function (fieldData) {\n      var name = fieldData.name,\n          data = _objectWithoutProperties(fieldData, _excluded);\n\n      var namePath = getNamePath(name);\n      namePathList.push(namePath); // Value\n\n      if ('value' in data) {\n        _this.updateStore(setValue(_this.store, namePath, data.value));\n      }\n\n      _this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n\n    _this.notifyWatch(namePathList);\n  });\n\n  _defineProperty(this, \"getFields\", function () {\n    var entities = _this.getFieldEntities(true);\n\n    var fields = entities.map(function (field) {\n      var namePath = field.getNamePath();\n      var meta = field.getMeta();\n\n      var fieldData = _objectSpread(_objectSpread({}, meta), {}, {\n        name: namePath,\n        value: _this.getFieldValue(namePath)\n      });\n\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  }); // =========================== Observer ===========================\n\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n\n\n  _defineProperty(this, \"initEntityValue\", function (entity) {\n    var initialValue = entity.props.initialValue;\n\n    if (initialValue !== undefined) {\n      var namePath = entity.getNamePath();\n      var prevValue = getValue(_this.store, namePath);\n\n      if (prevValue === undefined) {\n        _this.updateStore(setValue(_this.store, namePath, initialValue));\n      }\n    }\n  });\n\n  _defineProperty(this, \"isMergedPreserve\", function (fieldPreserve) {\n    var mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : _this.preserve;\n    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;\n  });\n\n  _defineProperty(this, \"registerField\", function (entity) {\n    _this.fieldEntities.push(entity);\n\n    var namePath = entity.getNamePath();\n\n    _this.notifyWatch([namePath]); // Set initial values\n\n\n    if (entity.props.initialValue !== undefined) {\n      var prevStore = _this.store;\n\n      _this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n\n      _this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    } // un-register field callback\n\n\n    return function (isListField, preserve) {\n      var subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      _this.fieldEntities = _this.fieldEntities.filter(function (item) {\n        return item !== entity;\n      }); // Clean up store value if not preserve\n\n      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        var defaultValue = isListField ? undefined : _this.getInitialValue(namePath);\n\n        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function (field) {\n          return (// Only reset when no namePath exist\n            !matchNamePath(field.getNamePath(), namePath)\n          );\n        })) {\n          var _prevStore = _this.store;\n\n          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true)); // Notify that field is unmount\n\n\n          _this.notifyObservers(_prevStore, [namePath], {\n            type: 'remove'\n          }); // Dependencies update\n\n\n          _this.triggerDependenciesUpdate(_prevStore, namePath);\n        }\n      }\n\n      _this.notifyWatch([namePath]);\n    };\n  });\n\n  _defineProperty(this, \"dispatch\", function (action) {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          var namePath = action.namePath,\n              value = action.value;\n\n          _this.updateValue(namePath, value);\n\n          break;\n        }\n\n      case 'validateField':\n        {\n          var _namePath = action.namePath,\n              triggerName = action.triggerName;\n\n          _this.validateFields([_namePath], {\n            triggerName: triggerName\n          });\n\n          break;\n        }\n\n      default: // Currently we don't have other action. Do nothing.\n\n    }\n  });\n\n  _defineProperty(this, \"notifyObservers\", function (prevStore, namePathList, info) {\n    if (_this.subscribable) {\n      var mergedInfo = _objectSpread(_objectSpread({}, info), {}, {\n        store: _this.getFieldsValue(true)\n      });\n\n      _this.getFieldEntities().forEach(function (_ref5) {\n        var onStoreChange = _ref5.onStoreChange;\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      _this.forceRootUpdate();\n    }\n  });\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n\n\n  _defineProperty(this, \"triggerDependenciesUpdate\", function (prevStore, namePath) {\n    var childrenFields = _this.getDependencyChildrenFields(namePath);\n\n    if (childrenFields.length) {\n      _this.validateFields(childrenFields);\n    }\n\n    _this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))\n    });\n\n    return childrenFields;\n  });\n\n  _defineProperty(this, \"updateValue\", function (name, value) {\n    var namePath = getNamePath(name);\n    var prevStore = _this.store;\n\n    _this.updateStore(setValue(_this.store, namePath, value));\n\n    _this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n\n    _this.notifyWatch([namePath]); // Dependencies update\n\n\n    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath); // trigger callback function\n\n\n    var onValuesChange = _this.callbacks.onValuesChange;\n\n    if (onValuesChange) {\n      var changedValues = cloneByNamePathList(_this.store, [namePath]);\n      onValuesChange(changedValues, _this.getFieldsValue());\n    }\n\n    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));\n  }); // Let all child Field get update.\n\n\n  _defineProperty(this, \"setFieldsValue\", function (store) {\n    _this.warningUnhooked();\n\n    var prevStore = _this.store;\n\n    if (store) {\n      var nextStore = merge(_this.store, store);\n\n      _this.updateStore(nextStore);\n    }\n\n    _this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n\n    _this.notifyWatch();\n  });\n\n  _defineProperty(this, \"setFieldValue\", function (name, value) {\n    _this.setFields([{\n      name: name,\n      value: value\n    }]);\n  });\n\n  _defineProperty(this, \"getDependencyChildrenFields\", function (rootNamePath) {\n    var children = new Set();\n    var childrenFields = [];\n    var dependencies2fields = new NameMap();\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n\n    _this.getFieldEntities().forEach(function (field) {\n      var dependencies = field.props.dependencies;\n      (dependencies || []).forEach(function (dependency) {\n        var dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, function () {\n          var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n\n    var fillChildren = function fillChildren(namePath) {\n      var fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(function (field) {\n        if (!children.has(field)) {\n          children.add(field);\n          var fieldNamePath = field.getNamePath();\n\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n\n    fillChildren(rootNamePath);\n    return childrenFields;\n  });\n\n  _defineProperty(this, \"triggerOnFieldsChange\", function (namePathList, filedErrors) {\n    var onFieldsChange = _this.callbacks.onFieldsChange;\n\n    if (onFieldsChange) {\n      var fields = _this.getFields();\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n\n\n      if (filedErrors) {\n        var cache = new NameMap();\n        filedErrors.forEach(function (_ref6) {\n          var name = _ref6.name,\n              errors = _ref6.errors;\n          cache.set(name, errors);\n        });\n        fields.forEach(function (field) {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n\n      var changedFields = fields.filter(function (_ref7) {\n        var fieldName = _ref7.name;\n        return containsNamePath(namePathList, fieldName);\n      });\n\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  }); // =========================== Validate ===========================\n\n\n  _defineProperty(this, \"validateFields\", function (arg1, arg2) {\n    _this.warningUnhooked();\n\n    var nameList;\n    var options;\n\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n\n    var provideNameList = !!nameList;\n    var namePathList = provideNameList ? nameList.map(getNamePath) : []; // Collect result in promise list\n\n    var promiseList = []; // We temp save the path which need trigger for `onFieldsChange`\n\n    var TMP_SPLIT = String(Date.now());\n    var validateNamePathList = new Set();\n\n    var _ref8 = options || {},\n        recursive = _ref8.recursive,\n        dirty = _ref8.dirty;\n\n    _this.getFieldEntities(true).forEach(function (field) {\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        namePathList.push(field.getNamePath());\n      } // Skip if without rule\n\n\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      } // Skip if only validate dirty field\n\n\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n\n      var fieldNamePath = field.getNamePath();\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT)); // Add field validate rule in to promise list\n\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        var promise = field.validateRules(_objectSpread({\n          validateMessages: _objectSpread(_objectSpread({}, defaultValidateMessages), _this.validateMessages)\n        }, options)); // Wrap promise with field\n\n        promiseList.push(promise.then(function () {\n          return {\n            name: fieldNamePath,\n            errors: [],\n            warnings: []\n          };\n        }).catch(function (ruleErrors) {\n          var _ruleErrors$forEach;\n\n          var mergedErrors = [];\n          var mergedWarnings = [];\n          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function (_ref9) {\n            var warningOnly = _ref9.rule.warningOnly,\n                errors = _ref9.errors;\n\n            if (warningOnly) {\n              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));\n            } else {\n              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));\n            }\n          });\n\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n\n    var summaryPromise = allPromiseFinish(promiseList);\n    _this.lastValidatePromise = summaryPromise; // Notify fields with rule that validate has finished and need update\n\n    summaryPromise.catch(function (results) {\n      return results;\n    }).then(function (results) {\n      var resultNamePathList = results.map(function (_ref10) {\n        var name = _ref10.name;\n        return name;\n      });\n\n      _this.notifyObservers(_this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n\n      _this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    var returnPromise = summaryPromise.then(function () {\n      if (_this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(_this.getFieldsValue(namePathList));\n      }\n\n      return Promise.reject([]);\n    }).catch(function (results) {\n      var errorList = results.filter(function (result) {\n        return result && result.errors.length;\n      });\n      return Promise.reject({\n        values: _this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: _this.lastValidatePromise !== summaryPromise\n      });\n    }); // Do not throw in console\n\n    returnPromise.catch(function (e) {\n      return e;\n    }); // `validating` changed. Trigger `onFieldsChange`\n\n    var triggerNamePathList = namePathList.filter(function (namePath) {\n      return validateNamePathList.has(namePath.join(TMP_SPLIT));\n    });\n\n    _this.triggerOnFieldsChange(triggerNamePathList);\n\n    return returnPromise;\n  }); // ============================ Submit ============================\n\n\n  _defineProperty(this, \"submit\", function () {\n    _this.warningUnhooked();\n\n    _this.validateFields().then(function (values) {\n      var onFinish = _this.callbacks.onFinish;\n\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(function (e) {\n      var onFinishFailed = _this.callbacks.onFinishFailed;\n\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  });\n\n  this.forceRootUpdate = forceRootUpdate;\n});\n\nfunction useForm(form) {\n  var formRef = React.useRef();\n\n  var _React$useState = React.useState({}),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      forceUpdate = _React$useState2[1];\n\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      var forceReRender = function forceReRender() {\n        forceUpdate({});\n      };\n\n      var formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n\n  return [formRef.current];\n}\n\nexport default useForm;","map":{"version":3,"sources":["D:/WED/SpotifyProject-master/node_modules/rc-field-form/es/useForm.js"],"names":["_slicedToArray","_objectSpread","_objectWithoutProperties","_toConsumableArray","_typeof","_createClass","_classCallCheck","_defineProperty","_excluded","merge","warning","React","HOOK_MARK","allPromiseFinish","defaultValidateMessages","NameMap","cloneByNamePathList","containsNamePath","getNamePath","getValue","matchNamePath","setValue","FormStore","forceRootUpdate","_this","getFieldValue","getFieldsValue","getFieldError","getFieldWarning","getFieldsError","isFieldsTouched","isFieldTouched","isFieldValidating","isFieldsValidating","resetFields","setFields","setFieldValue","setFieldsValue","validateFields","submit","_init","getInternalHooks","key","formHooked","dispatch","initEntityValue","registerField","useSubscribe","setInitialValues","destroyForm","setCallbacks","setValidateMessages","getFields","setPreserve","getInitialValue","registerWatch","subscribable","initialValues","init","_this$prevWithoutPres","nextStore","store","prevWithoutPreserves","map","_ref","namePath","updateStore","getFieldEntities","forEach","entity","isMergedPreserve","isPreserve","set","initValue","length","callbacks","validateMessages","preserve","callback","watchList","push","filter","fn","arguments","undefined","values","allValues","process","env","NODE_ENV","timeoutId","window","setTimeout","pure","fieldEntities","field","cache","nameList","getFieldsMap","name","get","INVALIDATE_NAME_PATH","filterFunc","warningUnhooked","mergedNameList","mergedFilterFunc","mergedStrict","Array","isArray","strict","getFieldEntitiesForNamePathList","filteredNameList","_isListField","_ref3","_isList","_ref2","isList","call","isListField","meta","getMeta","index","errors","getErrors","warnings","getWarnings","fieldError","_len","args","_key","arg0","arg1","namePathList","isAllFieldsTouched","every","some","shortNamePath","fieldNamePath","nameUnit","i","update","list","concat","isNamePathListTouched","entities","namePathListEntities","_ref4","value","testField","info","initialValue","props","records","Set","add","resetWithFields","formInitialValue","join","size","originValue","skipExist","requiredFieldEntities","_requiredFieldEntitie","apply","r","prevStore","resetWithFieldInitialValue","notifyObservers","type","notifyWatch","fields","fieldData","data","Object","defineProperty","prevValue","fieldPreserve","mergedPreserve","source","subNamePath","item","defaultValue","_prevStore","triggerDependenciesUpdate","action","updateValue","_namePath","triggerName","mergedInfo","_ref5","onStoreChange","childrenFields","getDependencyChildrenFields","relatedFields","onValuesChange","changedValues","triggerOnFieldsChange","rootNamePath","children","dependencies2fields","dependencies","dependency","dependencyNamePath","fillChildren","has","isFieldDirty","filedErrors","onFieldsChange","_ref6","changedFields","_ref7","fieldName","arg2","options","provideNameList","promiseList","TMP_SPLIT","String","Date","now","validateNamePathList","_ref8","recursive","dirty","rules","promise","validateRules","then","catch","ruleErrors","_ruleErrors$forEach","mergedErrors","mergedWarnings","_ref9","warningOnly","rule","Promise","reject","summaryPromise","lastValidatePromise","results","resultNamePathList","_ref10","returnPromise","resolve","errorList","result","errorFields","outOfDate","e","triggerNamePathList","onFinish","err","console","error","onFinishFailed","useForm","form","formRef","useRef","_React$useState","useState","_React$useState2","forceUpdate","current","forceReRender","formStore","getForm"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _excluded = [\"name\"];\nimport { merge } from \"rc-util/es/utils/set\";\nimport warning from \"rc-util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"./FieldContext\";\nimport { allPromiseFinish } from \"./utils/asyncUtil\";\nimport { defaultValidateMessages } from \"./utils/messages\";\nimport NameMap from \"./utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"./utils/valueUtil\";\nexport var FormStore = /*#__PURE__*/_createClass(function FormStore(forceRootUpdate) {\n  var _this = this;\n  _classCallCheck(this, FormStore);\n  _defineProperty(this, \"formHooked\", false);\n  _defineProperty(this, \"forceRootUpdate\", void 0);\n  _defineProperty(this, \"subscribable\", true);\n  _defineProperty(this, \"store\", {});\n  _defineProperty(this, \"fieldEntities\", []);\n  _defineProperty(this, \"initialValues\", {});\n  _defineProperty(this, \"callbacks\", {});\n  _defineProperty(this, \"validateMessages\", null);\n  _defineProperty(this, \"preserve\", null);\n  _defineProperty(this, \"lastValidatePromise\", null);\n  _defineProperty(this, \"getForm\", function () {\n    return {\n      getFieldValue: _this.getFieldValue,\n      getFieldsValue: _this.getFieldsValue,\n      getFieldError: _this.getFieldError,\n      getFieldWarning: _this.getFieldWarning,\n      getFieldsError: _this.getFieldsError,\n      isFieldsTouched: _this.isFieldsTouched,\n      isFieldTouched: _this.isFieldTouched,\n      isFieldValidating: _this.isFieldValidating,\n      isFieldsValidating: _this.isFieldsValidating,\n      resetFields: _this.resetFields,\n      setFields: _this.setFields,\n      setFieldValue: _this.setFieldValue,\n      setFieldsValue: _this.setFieldsValue,\n      validateFields: _this.validateFields,\n      submit: _this.submit,\n      _init: true,\n      getInternalHooks: _this.getInternalHooks\n    };\n  });\n  // ======================== Internal Hooks ========================\n  _defineProperty(this, \"getInternalHooks\", function (key) {\n    if (key === HOOK_MARK) {\n      _this.formHooked = true;\n      return {\n        dispatch: _this.dispatch,\n        initEntityValue: _this.initEntityValue,\n        registerField: _this.registerField,\n        useSubscribe: _this.useSubscribe,\n        setInitialValues: _this.setInitialValues,\n        destroyForm: _this.destroyForm,\n        setCallbacks: _this.setCallbacks,\n        setValidateMessages: _this.setValidateMessages,\n        getFields: _this.getFields,\n        setPreserve: _this.setPreserve,\n        getInitialValue: _this.getInitialValue,\n        registerWatch: _this.registerWatch\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  });\n  _defineProperty(this, \"useSubscribe\", function (subscribable) {\n    _this.subscribable = subscribable;\n  });\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  _defineProperty(this, \"prevWithoutPreserves\", null);\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  _defineProperty(this, \"setInitialValues\", function (initialValues, init) {\n    _this.initialValues = initialValues || {};\n    if (init) {\n      var _this$prevWithoutPres;\n      var nextStore = merge(initialValues, _this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(function (_ref) {\n        var namePath = _ref.key;\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      _this.prevWithoutPreserves = null;\n      _this.updateStore(nextStore);\n    }\n  });\n  _defineProperty(this, \"destroyForm\", function () {\n    var prevWithoutPreserves = new NameMap();\n    _this.getFieldEntities(true).forEach(function (entity) {\n      if (!_this.isMergedPreserve(entity.isPreserve())) {\n        prevWithoutPreserves.set(entity.getNamePath(), true);\n      }\n    });\n    _this.prevWithoutPreserves = prevWithoutPreserves;\n  });\n  _defineProperty(this, \"getInitialValue\", function (namePath) {\n    var initValue = getValue(_this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  });\n  _defineProperty(this, \"setCallbacks\", function (callbacks) {\n    _this.callbacks = callbacks;\n  });\n  _defineProperty(this, \"setValidateMessages\", function (validateMessages) {\n    _this.validateMessages = validateMessages;\n  });\n  _defineProperty(this, \"setPreserve\", function (preserve) {\n    _this.preserve = preserve;\n  });\n  // ============================= Watch ============================\n  _defineProperty(this, \"watchList\", []);\n  _defineProperty(this, \"registerWatch\", function (callback) {\n    _this.watchList.push(callback);\n    return function () {\n      _this.watchList = _this.watchList.filter(function (fn) {\n        return fn !== callback;\n      });\n    };\n  });\n  _defineProperty(this, \"notifyWatch\", function () {\n    var namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    // No need to cost perf when nothing need to watch\n    if (_this.watchList.length) {\n      var values = _this.getFieldsValue();\n      var allValues = _this.getFieldsValue(true);\n      _this.watchList.forEach(function (callback) {\n        callback(values, allValues, namePath);\n      });\n    }\n  });\n  // ========================== Dev Warning =========================\n  _defineProperty(this, \"timeoutId\", null);\n  _defineProperty(this, \"warningUnhooked\", function () {\n    if (process.env.NODE_ENV !== 'production' && !_this.timeoutId && typeof window !== 'undefined') {\n      _this.timeoutId = setTimeout(function () {\n        _this.timeoutId = null;\n        if (!_this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  });\n  // ============================ Store =============================\n  _defineProperty(this, \"updateStore\", function (nextStore) {\n    _this.store = nextStore;\n  });\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  _defineProperty(this, \"getFieldEntities\", function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!pure) {\n      return _this.fieldEntities;\n    }\n    return _this.fieldEntities.filter(function (field) {\n      return field.getNamePath().length;\n    });\n  });\n  _defineProperty(this, \"getFieldsMap\", function () {\n    var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cache = new NameMap();\n    _this.getFieldEntities(pure).forEach(function (field) {\n      var namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  });\n  _defineProperty(this, \"getFieldEntitiesForNamePathList\", function (nameList) {\n    if (!nameList) {\n      return _this.getFieldEntities(true);\n    }\n    var cache = _this.getFieldsMap(true);\n    return nameList.map(function (name) {\n      var namePath = getNamePath(name);\n      return cache.get(namePath) || {\n        INVALIDATE_NAME_PATH: getNamePath(name)\n      };\n    });\n  });\n  _defineProperty(this, \"getFieldsValue\", function (nameList, filterFunc) {\n    _this.warningUnhooked();\n\n    // Fill args\n    var mergedNameList;\n    var mergedFilterFunc;\n    var mergedStrict;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && _typeof(nameList) === 'object') {\n      mergedStrict = nameList.strict;\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return _this.store;\n    }\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);\n    var filteredNameList = [];\n    fieldEntities.forEach(function (entity) {\n      var _isListField, _ref3;\n      var namePath = 'INVALIDATE_NAME_PATH' in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (mergedStrict) {\n        var _isList, _ref2;\n        if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2)) {\n          return;\n        }\n      } else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3)) {\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        var meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));\n  });\n  _defineProperty(this, \"getFieldValue\", function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    return getValue(_this.store, namePath);\n  });\n  _defineProperty(this, \"getFieldsError\", function (nameList) {\n    _this.warningUnhooked();\n    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map(function (entity, index) {\n      if (entity && !('INVALIDATE_NAME_PATH' in entity)) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  });\n  _defineProperty(this, \"getFieldError\", function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    var fieldError = _this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  });\n  _defineProperty(this, \"getFieldWarning\", function (name) {\n    _this.warningUnhooked();\n    var namePath = getNamePath(name);\n    var fieldError = _this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  });\n  _defineProperty(this, \"isFieldsTouched\", function () {\n    _this.warningUnhooked();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var arg0 = args[0],\n      arg1 = args[1];\n    var namePathList;\n    var isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    var fieldEntities = _this.getFieldEntities(true);\n    var isFieldTouched = function isFieldTouched(field) {\n      return field.isFieldTouched();\n    };\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(function (entity) {\n        return isFieldTouched(entity) || entity.isList();\n      }) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    var map = new NameMap();\n    namePathList.forEach(function (shortNamePath) {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(function (field) {\n      var fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(function (shortNamePath) {\n        if (shortNamePath.every(function (nameUnit, i) {\n          return fieldNamePath[i] === nameUnit;\n        })) {\n          map.update(shortNamePath, function (list) {\n            return [].concat(_toConsumableArray(list), [field]);\n          });\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    var isNamePathListTouched = function isNamePathListTouched(entities) {\n      return entities.some(isFieldTouched);\n    };\n    var namePathListEntities = map.map(function (_ref4) {\n      var value = _ref4.value;\n      return value;\n    });\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  });\n  _defineProperty(this, \"isFieldTouched\", function (name) {\n    _this.warningUnhooked();\n    return _this.isFieldsTouched([name]);\n  });\n  _defineProperty(this, \"isFieldsValidating\", function (nameList) {\n    _this.warningUnhooked();\n    var fieldEntities = _this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(function (testField) {\n        return testField.isFieldValidating();\n      });\n    }\n    var namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(function (testField) {\n      var fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  });\n  _defineProperty(this, \"isFieldValidating\", function (name) {\n    _this.warningUnhooked();\n    return _this.isFieldsValidating([name]);\n  });\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  _defineProperty(this, \"resetWithFieldInitialValue\", function () {\n    var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // Create cache\n    var cache = new NameMap();\n    var fieldEntities = _this.getFieldEntities(true);\n    fieldEntities.forEach(function (field) {\n      var initialValue = field.props.initialValue;\n      var namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        var records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    var resetWithFields = function resetWithFields(entities) {\n      entities.forEach(function (field) {\n        var initialValue = field.props.initialValue;\n        if (initialValue !== undefined) {\n          var namePath = field.getNamePath();\n          var formInitialValue = _this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, \"Form already set 'initialValues' with path '\".concat(namePath.join('.'), \"'. Field can not overwrite it.\"));\n          } else {\n            var records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, \"Multiple Field with path '\".concat(namePath.join('.'), \"' set 'initialValue'. Can not decide which one to pick.\"));\n            } else if (records) {\n              var originValue = _this.getFieldValue(namePath);\n              var isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    var requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(function (namePath) {\n        var records = cache.get(namePath);\n        if (records) {\n          var _requiredFieldEntitie;\n          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function (r) {\n            return r.entity;\n          })));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  });\n  _defineProperty(this, \"resetFields\", function (nameList) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    if (!nameList) {\n      _this.updateStore(merge(_this.initialValues));\n      _this.resetWithFieldInitialValue();\n      _this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      _this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    var namePathList = nameList.map(getNamePath);\n    namePathList.forEach(function (namePath) {\n      var initialValue = _this.getInitialValue(namePath);\n      _this.updateStore(setValue(_this.store, namePath, initialValue));\n    });\n    _this.resetWithFieldInitialValue({\n      namePathList: namePathList\n    });\n    _this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    _this.notifyWatch(namePathList);\n  });\n  _defineProperty(this, \"setFields\", function (fields) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    var namePathList = [];\n    fields.forEach(function (fieldData) {\n      var name = fieldData.name,\n        data = _objectWithoutProperties(fieldData, _excluded);\n      var namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        _this.updateStore(setValue(_this.store, namePath, data.value));\n      }\n      _this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    _this.notifyWatch(namePathList);\n  });\n  _defineProperty(this, \"getFields\", function () {\n    var entities = _this.getFieldEntities(true);\n    var fields = entities.map(function (field) {\n      var namePath = field.getNamePath();\n      var meta = field.getMeta();\n      var fieldData = _objectSpread(_objectSpread({}, meta), {}, {\n        name: namePath,\n        value: _this.getFieldValue(namePath)\n      });\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  });\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  _defineProperty(this, \"initEntityValue\", function (entity) {\n    var initialValue = entity.props.initialValue;\n    if (initialValue !== undefined) {\n      var namePath = entity.getNamePath();\n      var prevValue = getValue(_this.store, namePath);\n      if (prevValue === undefined) {\n        _this.updateStore(setValue(_this.store, namePath, initialValue));\n      }\n    }\n  });\n  _defineProperty(this, \"isMergedPreserve\", function (fieldPreserve) {\n    var mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : _this.preserve;\n    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;\n  });\n  _defineProperty(this, \"registerField\", function (entity) {\n    _this.fieldEntities.push(entity);\n    var namePath = entity.getNamePath();\n    _this.notifyWatch([namePath]);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      var prevStore = _this.store;\n      _this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      _this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return function (isListField, preserve) {\n      var subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      _this.fieldEntities = _this.fieldEntities.filter(function (item) {\n        return item !== entity;\n      });\n\n      // Clean up store value if not preserve\n      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        var defaultValue = isListField ? undefined : _this.getInitialValue(namePath);\n        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function (field) {\n          return (\n            // Only reset when no namePath exist\n            !matchNamePath(field.getNamePath(), namePath)\n          );\n        })) {\n          var _prevStore = _this.store;\n          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          _this.notifyObservers(_prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          _this.triggerDependenciesUpdate(_prevStore, namePath);\n        }\n      }\n      _this.notifyWatch([namePath]);\n    };\n  });\n  _defineProperty(this, \"dispatch\", function (action) {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          var namePath = action.namePath,\n            value = action.value;\n          _this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          var _namePath = action.namePath,\n            triggerName = action.triggerName;\n          _this.validateFields([_namePath], {\n            triggerName: triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  });\n  _defineProperty(this, \"notifyObservers\", function (prevStore, namePathList, info) {\n    if (_this.subscribable) {\n      var mergedInfo = _objectSpread(_objectSpread({}, info), {}, {\n        store: _this.getFieldsValue(true)\n      });\n      _this.getFieldEntities().forEach(function (_ref5) {\n        var onStoreChange = _ref5.onStoreChange;\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      _this.forceRootUpdate();\n    }\n  });\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  _defineProperty(this, \"triggerDependenciesUpdate\", function (prevStore, namePath) {\n    var childrenFields = _this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      _this.validateFields(childrenFields);\n    }\n    _this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))\n    });\n    return childrenFields;\n  });\n  _defineProperty(this, \"updateValue\", function (name, value) {\n    var namePath = getNamePath(name);\n    var prevStore = _this.store;\n    _this.updateStore(setValue(_this.store, namePath, value));\n    _this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    _this.notifyWatch([namePath]);\n\n    // Dependencies update\n    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    var onValuesChange = _this.callbacks.onValuesChange;\n    if (onValuesChange) {\n      var changedValues = cloneByNamePathList(_this.store, [namePath]);\n      onValuesChange(changedValues, _this.getFieldsValue());\n    }\n    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));\n  });\n  // Let all child Field get update.\n  _defineProperty(this, \"setFieldsValue\", function (store) {\n    _this.warningUnhooked();\n    var prevStore = _this.store;\n    if (store) {\n      var nextStore = merge(_this.store, store);\n      _this.updateStore(nextStore);\n    }\n    _this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    _this.notifyWatch();\n  });\n  _defineProperty(this, \"setFieldValue\", function (name, value) {\n    _this.setFields([{\n      name: name,\n      value: value\n    }]);\n  });\n  _defineProperty(this, \"getDependencyChildrenFields\", function (rootNamePath) {\n    var children = new Set();\n    var childrenFields = [];\n    var dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    _this.getFieldEntities().forEach(function (field) {\n      var dependencies = field.props.dependencies;\n      (dependencies || []).forEach(function (dependency) {\n        var dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, function () {\n          var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    var fillChildren = function fillChildren(namePath) {\n      var fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(function (field) {\n        if (!children.has(field)) {\n          children.add(field);\n          var fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  });\n  _defineProperty(this, \"triggerOnFieldsChange\", function (namePathList, filedErrors) {\n    var onFieldsChange = _this.callbacks.onFieldsChange;\n    if (onFieldsChange) {\n      var fields = _this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        var cache = new NameMap();\n        filedErrors.forEach(function (_ref6) {\n          var name = _ref6.name,\n            errors = _ref6.errors;\n          cache.set(name, errors);\n        });\n        fields.forEach(function (field) {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      var changedFields = fields.filter(function (_ref7) {\n        var fieldName = _ref7.name;\n        return containsNamePath(namePathList, fieldName);\n      });\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  });\n  // =========================== Validate ===========================\n  _defineProperty(this, \"validateFields\", function (arg1, arg2) {\n    _this.warningUnhooked();\n    var nameList;\n    var options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    var provideNameList = !!nameList;\n    var namePathList = provideNameList ? nameList.map(getNamePath) : [];\n\n    // Collect result in promise list\n    var promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    var TMP_SPLIT = String(Date.now());\n    var validateNamePathList = new Set();\n    var _ref8 = options || {},\n      recursive = _ref8.recursive,\n      dirty = _ref8.dirty;\n    _this.getFieldEntities(true).forEach(function (field) {\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        namePathList.push(field.getNamePath());\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      var fieldNamePath = field.getNamePath();\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        var promise = field.validateRules(_objectSpread({\n          validateMessages: _objectSpread(_objectSpread({}, defaultValidateMessages), _this.validateMessages)\n        }, options));\n\n        // Wrap promise with field\n        promiseList.push(promise.then(function () {\n          return {\n            name: fieldNamePath,\n            errors: [],\n            warnings: []\n          };\n        }).catch(function (ruleErrors) {\n          var _ruleErrors$forEach;\n          var mergedErrors = [];\n          var mergedWarnings = [];\n          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function (_ref9) {\n            var warningOnly = _ref9.rule.warningOnly,\n              errors = _ref9.errors;\n            if (warningOnly) {\n              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));\n            } else {\n              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    var summaryPromise = allPromiseFinish(promiseList);\n    _this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(function (results) {\n      return results;\n    }).then(function (results) {\n      var resultNamePathList = results.map(function (_ref10) {\n        var name = _ref10.name;\n        return name;\n      });\n      _this.notifyObservers(_this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      _this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    var returnPromise = summaryPromise.then(function () {\n      if (_this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(_this.getFieldsValue(namePathList));\n      }\n      return Promise.reject([]);\n    }).catch(function (results) {\n      var errorList = results.filter(function (result) {\n        return result && result.errors.length;\n      });\n      return Promise.reject({\n        values: _this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: _this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(function (e) {\n      return e;\n    });\n\n    // `validating` changed. Trigger `onFieldsChange`\n    var triggerNamePathList = namePathList.filter(function (namePath) {\n      return validateNamePathList.has(namePath.join(TMP_SPLIT));\n    });\n    _this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  });\n  // ============================ Submit ============================\n  _defineProperty(this, \"submit\", function () {\n    _this.warningUnhooked();\n    _this.validateFields().then(function (values) {\n      var onFinish = _this.callbacks.onFinish;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(function (e) {\n      var onFinishFailed = _this.callbacks.onFinishFailed;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  });\n  this.forceRootUpdate = forceRootUpdate;\n});\nfunction useForm(form) {\n  var formRef = React.useRef();\n  var _React$useState = React.useState({}),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    forceUpdate = _React$useState2[1];\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      var forceReRender = function forceReRender() {\n        forceUpdate({});\n      };\n      var formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;"]},"metadata":{},"sourceType":"module"}