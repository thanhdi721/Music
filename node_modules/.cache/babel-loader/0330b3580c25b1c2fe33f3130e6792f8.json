{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport warning from \"rc-util/es/warning\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport { isFormInstance } from \"./utils/typeUtil\";\nimport { getNamePath, getValue } from \"./utils/valueUtil\";\nexport function stringify(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    return Math.random();\n  }\n}\nvar useWatchWarning = process.env.NODE_ENV !== 'production' ? function (namePath) {\n  var fullyStr = namePath.join('__RC_FIELD_FORM_SPLIT__');\n  var nameStrRef = useRef(fullyStr);\n  warning(nameStrRef.current === fullyStr, '`useWatch` is not support dynamic `namePath`. Please provide static instead.');\n} : function () {}; // ------- selector type -------\n// ------- selector type end -------\n\nfunction useWatch() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var dependencies = args[0],\n      _args$ = args[1],\n      _form = _args$ === void 0 ? {} : _args$;\n\n  var options = isFormInstance(_form) ? {\n    form: _form\n  } : _form;\n  var form = options.form;\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      value = _useState2[0],\n      setValue = _useState2[1];\n\n  var valueStr = useMemo(function () {\n    return stringify(value);\n  }, [value]);\n  var valueStrRef = useRef(valueStr);\n  valueStrRef.current = valueStr;\n  var fieldContext = useContext(FieldContext);\n  var formInstance = form || fieldContext;\n  var isValidForm = formInstance && formInstance._init; // Warning if not exist form instance\n\n  if (process.env.NODE_ENV !== 'production') {\n    warning(args.length === 2 ? form ? isValidForm : true : isValidForm, 'useWatch requires a form instance since it can not auto detect from context.');\n  }\n\n  var namePath = getNamePath(dependencies);\n  var namePathRef = useRef(namePath);\n  namePathRef.current = namePath;\n  useWatchWarning(namePath);\n  useEffect(function () {\n    // Skip if not exist form instance\n    if (!isValidForm) {\n      return;\n    }\n\n    var getFieldsValue = formInstance.getFieldsValue,\n        getInternalHooks = formInstance.getInternalHooks;\n\n    var _getInternalHooks = getInternalHooks(HOOK_MARK),\n        registerWatch = _getInternalHooks.registerWatch;\n\n    var getWatchValue = function getWatchValue(values, allValues) {\n      var watchValue = options.preserve ? allValues : values;\n      return typeof dependencies === 'function' ? dependencies(watchValue) : getValue(watchValue, namePathRef.current);\n    };\n\n    var cancelRegister = registerWatch(function (values, allValues) {\n      var newValue = getWatchValue(values, allValues);\n      var nextValueStr = stringify(newValue); // Compare stringify in case it's nest object\n\n      if (valueStrRef.current !== nextValueStr) {\n        valueStrRef.current = nextValueStr;\n        setValue(newValue);\n      }\n    }); // TODO: We can improve this perf in future\n\n    var initialValue = getWatchValue(getFieldsValue(), getFieldsValue(true)); // React 18 has the bug that will queue update twice even the value is not changed\n    // ref: https://github.com/facebook/react/issues/27213\n\n    if (value !== initialValue) {\n      setValue(initialValue);\n    }\n\n    return cancelRegister;\n  }, // We do not need re-register since namePath content is the same\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [isValidForm]);\n  return value;\n}\n\nexport default useWatch;","map":{"version":3,"sources":["D:/WED/SpotifyProject-master/node_modules/rc-field-form/es/useWatch.js"],"names":["_slicedToArray","warning","useContext","useEffect","useMemo","useRef","useState","FieldContext","HOOK_MARK","isFormInstance","getNamePath","getValue","stringify","value","JSON","err","Math","random","useWatchWarning","process","env","NODE_ENV","namePath","fullyStr","join","nameStrRef","current","useWatch","_len","arguments","length","args","Array","_key","dependencies","_args$","_form","options","form","_useState","_useState2","setValue","valueStr","valueStrRef","fieldContext","formInstance","isValidForm","_init","namePathRef","getFieldsValue","getInternalHooks","_getInternalHooks","registerWatch","getWatchValue","values","allValues","watchValue","preserve","cancelRegister","newValue","nextValueStr","initialValue"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport warning from \"rc-util/es/warning\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport { isFormInstance } from \"./utils/typeUtil\";\nimport { getNamePath, getValue } from \"./utils/valueUtil\";\nexport function stringify(value) {\n  try {\n    return JSON.stringify(value);\n  } catch (err) {\n    return Math.random();\n  }\n}\nvar useWatchWarning = process.env.NODE_ENV !== 'production' ? function (namePath) {\n  var fullyStr = namePath.join('__RC_FIELD_FORM_SPLIT__');\n  var nameStrRef = useRef(fullyStr);\n  warning(nameStrRef.current === fullyStr, '`useWatch` is not support dynamic `namePath`. Please provide static instead.');\n} : function () {};\n\n// ------- selector type -------\n\n// ------- selector type end -------\n\nfunction useWatch() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var dependencies = args[0],\n    _args$ = args[1],\n    _form = _args$ === void 0 ? {} : _args$;\n  var options = isFormInstance(_form) ? {\n    form: _form\n  } : _form;\n  var form = options.form;\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    value = _useState2[0],\n    setValue = _useState2[1];\n  var valueStr = useMemo(function () {\n    return stringify(value);\n  }, [value]);\n  var valueStrRef = useRef(valueStr);\n  valueStrRef.current = valueStr;\n  var fieldContext = useContext(FieldContext);\n  var formInstance = form || fieldContext;\n  var isValidForm = formInstance && formInstance._init;\n\n  // Warning if not exist form instance\n  if (process.env.NODE_ENV !== 'production') {\n    warning(args.length === 2 ? form ? isValidForm : true : isValidForm, 'useWatch requires a form instance since it can not auto detect from context.');\n  }\n  var namePath = getNamePath(dependencies);\n  var namePathRef = useRef(namePath);\n  namePathRef.current = namePath;\n  useWatchWarning(namePath);\n  useEffect(function () {\n    // Skip if not exist form instance\n    if (!isValidForm) {\n      return;\n    }\n    var getFieldsValue = formInstance.getFieldsValue,\n      getInternalHooks = formInstance.getInternalHooks;\n    var _getInternalHooks = getInternalHooks(HOOK_MARK),\n      registerWatch = _getInternalHooks.registerWatch;\n    var getWatchValue = function getWatchValue(values, allValues) {\n      var watchValue = options.preserve ? allValues : values;\n      return typeof dependencies === 'function' ? dependencies(watchValue) : getValue(watchValue, namePathRef.current);\n    };\n    var cancelRegister = registerWatch(function (values, allValues) {\n      var newValue = getWatchValue(values, allValues);\n      var nextValueStr = stringify(newValue);\n\n      // Compare stringify in case it's nest object\n      if (valueStrRef.current !== nextValueStr) {\n        valueStrRef.current = nextValueStr;\n        setValue(newValue);\n      }\n    });\n\n    // TODO: We can improve this perf in future\n    var initialValue = getWatchValue(getFieldsValue(), getFieldsValue(true));\n\n    // React 18 has the bug that will queue update twice even the value is not changed\n    // ref: https://github.com/facebook/react/issues/27213\n    if (value !== initialValue) {\n      setValue(initialValue);\n    }\n    return cancelRegister;\n  },\n  // We do not need re-register since namePath content is the same\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [isValidForm]);\n  return value;\n}\nexport default useWatch;"]},"metadata":{},"sourceType":"module"}