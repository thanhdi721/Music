{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar FORMAT_KEYS = ['YYYY', 'MM', 'DD', 'HH', 'mm', 'ss', 'SSS']; // Use Chinese character to avoid conflict with the mask format\n\nvar REPLACE_KEY = '顧';\n\nvar MaskFormat = /*#__PURE__*/function () {\n  function MaskFormat(format) {\n    _classCallCheck(this, MaskFormat);\n\n    _defineProperty(this, \"format\", void 0);\n\n    _defineProperty(this, \"maskFormat\", void 0);\n\n    _defineProperty(this, \"cells\", void 0);\n\n    _defineProperty(this, \"maskCells\", void 0);\n\n    this.format = format; // Generate mask format\n\n    var replaceKeys = FORMAT_KEYS.map(function (key) {\n      return \"(\".concat(key, \")\");\n    }).join('|');\n    var replaceReg = new RegExp(replaceKeys, 'g');\n    this.maskFormat = format.replace(replaceReg, // Use Chinese character to avoid user use it in format\n    function (key) {\n      return REPLACE_KEY.repeat(key.length);\n    }); // Generate cells\n\n    var cellReg = new RegExp(\"(\".concat(FORMAT_KEYS.join('|'), \")\"));\n    var strCells = (format.split(cellReg) || []).filter(function (str) {\n      return str;\n    });\n    var offset = 0;\n    this.cells = strCells.map(function (text) {\n      var mask = FORMAT_KEYS.includes(text);\n      var start = offset;\n      var end = offset + text.length;\n      offset = end;\n      return {\n        text: text,\n        mask: mask,\n        start: start,\n        end: end\n      };\n    }); // Mask cells\n\n    this.maskCells = this.cells.filter(function (cell) {\n      return cell.mask;\n    });\n  }\n\n  _createClass(MaskFormat, [{\n    key: \"getSelection\",\n    value: function getSelection(maskCellIndex) {\n      var _ref = this.maskCells[maskCellIndex] || {},\n          start = _ref.start,\n          end = _ref.end;\n\n      return [start || 0, end || 0];\n    }\n    /** Check given text match format */\n\n  }, {\n    key: \"match\",\n    value: function match(text) {\n      for (var i = 0; i < this.maskFormat.length; i += 1) {\n        var maskChar = this.maskFormat[i];\n        var textChar = text[i];\n\n        if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /** Get mask cell count */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.maskCells.length;\n    }\n  }, {\n    key: \"getMaskCellIndex\",\n    value: function getMaskCellIndex(anchorIndex) {\n      var closetDist = Number.MAX_SAFE_INTEGER;\n      var closetIndex = 0;\n\n      for (var i = 0; i < this.maskCells.length; i += 1) {\n        var _this$maskCells$i = this.maskCells[i],\n            start = _this$maskCells$i.start,\n            end = _this$maskCells$i.end;\n\n        if (anchorIndex >= start && anchorIndex <= end) {\n          return i;\n        }\n\n        var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));\n\n        if (dist < closetDist) {\n          closetDist = dist;\n          closetIndex = i;\n        }\n      }\n\n      return closetIndex;\n    }\n  }]);\n\n  return MaskFormat;\n}();\n\nexport { MaskFormat as default };","map":{"version":3,"sources":["D:/WED/SpotifyProject-master/node_modules/rc-picker/es/PickerInput/Selector/MaskFormat.js"],"names":["_classCallCheck","_createClass","_defineProperty","FORMAT_KEYS","REPLACE_KEY","MaskFormat","format","replaceKeys","map","key","concat","join","replaceReg","RegExp","maskFormat","replace","repeat","length","cellReg","strCells","split","filter","str","offset","cells","text","mask","includes","start","end","maskCells","cell","value","getSelection","maskCellIndex","_ref","match","i","maskChar","textChar","size","getMaskCellIndex","anchorIndex","closetDist","Number","MAX_SAFE_INTEGER","closetIndex","_this$maskCells$i","dist","Math","min","abs","default"],"mappings":"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","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar FORMAT_KEYS = ['YYYY', 'MM', 'DD', 'HH', 'mm', 'ss', 'SSS'];\n// Use Chinese character to avoid conflict with the mask format\nvar REPLACE_KEY = '顧';\nvar MaskFormat = /*#__PURE__*/function () {\n  function MaskFormat(format) {\n    _classCallCheck(this, MaskFormat);\n    _defineProperty(this, \"format\", void 0);\n    _defineProperty(this, \"maskFormat\", void 0);\n    _defineProperty(this, \"cells\", void 0);\n    _defineProperty(this, \"maskCells\", void 0);\n    this.format = format;\n\n    // Generate mask format\n    var replaceKeys = FORMAT_KEYS.map(function (key) {\n      return \"(\".concat(key, \")\");\n    }).join('|');\n    var replaceReg = new RegExp(replaceKeys, 'g');\n    this.maskFormat = format.replace(replaceReg,\n    // Use Chinese character to avoid user use it in format\n    function (key) {\n      return REPLACE_KEY.repeat(key.length);\n    });\n\n    // Generate cells\n    var cellReg = new RegExp(\"(\".concat(FORMAT_KEYS.join('|'), \")\"));\n    var strCells = (format.split(cellReg) || []).filter(function (str) {\n      return str;\n    });\n    var offset = 0;\n    this.cells = strCells.map(function (text) {\n      var mask = FORMAT_KEYS.includes(text);\n      var start = offset;\n      var end = offset + text.length;\n      offset = end;\n      return {\n        text: text,\n        mask: mask,\n        start: start,\n        end: end\n      };\n    });\n\n    // Mask cells\n    this.maskCells = this.cells.filter(function (cell) {\n      return cell.mask;\n    });\n  }\n  _createClass(MaskFormat, [{\n    key: \"getSelection\",\n    value: function getSelection(maskCellIndex) {\n      var _ref = this.maskCells[maskCellIndex] || {},\n        start = _ref.start,\n        end = _ref.end;\n      return [start || 0, end || 0];\n    }\n\n    /** Check given text match format */\n  }, {\n    key: \"match\",\n    value: function match(text) {\n      for (var i = 0; i < this.maskFormat.length; i += 1) {\n        var maskChar = this.maskFormat[i];\n        var textChar = text[i];\n        if (!textChar || maskChar !== REPLACE_KEY && maskChar !== textChar) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /** Get mask cell count */\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.maskCells.length;\n    }\n  }, {\n    key: \"getMaskCellIndex\",\n    value: function getMaskCellIndex(anchorIndex) {\n      var closetDist = Number.MAX_SAFE_INTEGER;\n      var closetIndex = 0;\n      for (var i = 0; i < this.maskCells.length; i += 1) {\n        var _this$maskCells$i = this.maskCells[i],\n          start = _this$maskCells$i.start,\n          end = _this$maskCells$i.end;\n        if (anchorIndex >= start && anchorIndex <= end) {\n          return i;\n        }\n        var dist = Math.min(Math.abs(anchorIndex - start), Math.abs(anchorIndex - end));\n        if (dist < closetDist) {\n          closetDist = dist;\n          closetIndex = i;\n        }\n      }\n      return closetIndex;\n    }\n  }]);\n  return MaskFormat;\n}();\nexport { MaskFormat as default };"]},"metadata":{},"sourceType":"module"}