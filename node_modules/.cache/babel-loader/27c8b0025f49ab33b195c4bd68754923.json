{"ast":null,"code":"\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nconst MeasureText = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n    style,\n    children\n  } = _ref;\n  const spanRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => ({\n    isExceed: () => {\n      const span = spanRef.current;\n      return span.scrollHeight > span.clientHeight;\n    },\n    getHeight: () => spanRef.current.clientHeight\n  }));\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: spanRef,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      // zIndex: -9999,\n      // visibility: 'hidden',\n      pointerEvents: 'none',\n      backgroundColor: 'rgba(255, 0, 0, 0.65)'\n    }, style)\n  }, children);\n});\n\nfunction cuttable(node) {\n  const type = typeof node;\n  return type === 'string' || type === 'number';\n}\n\nfunction getNodesLen(nodeList) {\n  let totalLen = 0;\n  nodeList.forEach(node => {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\n\nfunction sliceNodes(nodeList, len) {\n  let currLen = 0;\n  const currentNodeList = [];\n\n  for (let i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n\n    const node = nodeList[i];\n    const canCut = cuttable(node);\n    const nodeLen = canCut ? String(node).length : 1;\n    const nextLen = currLen + nodeLen; // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n\n    if (nextLen > len) {\n      const restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n\n  return nodeList;\n} // Measure for the `text` is exceed the `rows` or not\n\n\nconst STATUS_MEASURE_NONE = 0;\nconst STATUS_MEASURE_START = 1;\nconst STATUS_MEASURE_NEED_ELLIPSIS = 2;\nconst STATUS_MEASURE_NO_NEED_ELLIPSIS = 3;\nconst lineClipStyle = {\n  display: '-webkit-box',\n  overflow: 'hidden',\n  WebkitBoxOrient: 'vertical'\n};\nexport default function EllipsisMeasure(props) {\n  const {\n    enableMeasure,\n    width,\n    text,\n    children,\n    rows,\n    expanded,\n    miscDeps,\n    onEllipsis\n  } = props;\n  const nodeList = React.useMemo(() => toArray(text), [text]);\n  const nodeLen = React.useMemo(() => getNodesLen(nodeList), [text]); // ========================= Full Content =========================\n  // Used for measure only, which means it's always render as no need ellipsis\n\n  const fullContent = React.useMemo(() => children(nodeList, false), [text]); // ========================= Cut Content ==========================\n\n  const [ellipsisCutIndex, setEllipsisCutIndex] = React.useState(null);\n  const cutMidRef = React.useRef(null); // ========================= NeedEllipsis =========================\n\n  const needEllipsisRef = React.useRef(null); // Measure for `rows-1` height, to avoid operation exceed the line height\n\n  const descRowsEllipsisRef = React.useRef(null);\n  const symbolRowEllipsisRef = React.useRef(null);\n  const [canEllipsis, setCanEllipsis] = React.useState(false);\n  const [needEllipsis, setNeedEllipsis] = React.useState(STATUS_MEASURE_NONE);\n  const [ellipsisHeight, setEllipsisHeight] = React.useState(0); // Trigger start measure\n\n  useLayoutEffect(() => {\n    if (enableMeasure && width && nodeLen) {\n      setNeedEllipsis(STATUS_MEASURE_START);\n    } else {\n      setNeedEllipsis(STATUS_MEASURE_NONE);\n    }\n  }, [width, text, rows, enableMeasure, nodeList]); // Measure process\n\n  useLayoutEffect(() => {\n    var _a, _b, _c, _d;\n\n    if (needEllipsis === STATUS_MEASURE_START) {\n      const isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());\n      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);\n      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);\n      setCanEllipsis(isOverflow); // Get the basic height of ellipsis rows\n\n      const baseRowsEllipsisHeight = ((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0; // Get the height of `rows - 1` + symbol height\n\n      const descRowsEllipsisHeight = rows === 1 ? 0 : ((_c = descRowsEllipsisRef.current) === null || _c === void 0 ? void 0 : _c.getHeight()) || 0;\n      const symbolRowEllipsisHeight = ((_d = symbolRowEllipsisRef.current) === null || _d === void 0 ? void 0 : _d.getHeight()) || 0;\n      const rowsWithEllipsisHeight = descRowsEllipsisHeight + symbolRowEllipsisHeight;\n      const maxRowsHeight = Math.max(baseRowsEllipsisHeight, rowsWithEllipsisHeight);\n      setEllipsisHeight(maxRowsHeight + 1);\n      onEllipsis(isOverflow);\n    }\n  }, [needEllipsis]); // ========================= Cut Measure ==========================\n\n  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;\n  useLayoutEffect(() => {\n    var _a;\n\n    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];\n\n    if (minIndex !== maxIndex) {\n      const midHeight = ((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;\n      const isOverflow = midHeight > ellipsisHeight;\n      let targetMidIndex = cutMidIndex;\n\n      if (maxIndex - minIndex === 1) {\n        targetMidIndex = isOverflow ? minIndex : maxIndex;\n      }\n\n      if (isOverflow) {\n        setEllipsisCutIndex([minIndex, targetMidIndex]);\n      } else {\n        setEllipsisCutIndex([targetMidIndex, maxIndex]);\n      }\n    }\n  }, [ellipsisCutIndex, cutMidIndex]); // ========================= Text Content =========================\n\n  const finalContent = React.useMemo(() => {\n    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {\n      const content = children(nodeList, false); // Limit the max line count to avoid scrollbar blink\n      // https://github.com/ant-design/ant-design/issues/42958\n\n      if (needEllipsis !== STATUS_MEASURE_NO_NEED_ELLIPSIS && needEllipsis !== STATUS_MEASURE_NONE) {\n        return /*#__PURE__*/React.createElement(\"span\", {\n          style: Object.assign(Object.assign({}, lineClipStyle), {\n            WebkitLineClamp: rows\n          })\n        }, content);\n      }\n\n      return content;\n    }\n\n    return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);\n  }, [expanded, needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps))); // ============================ Render ============================\n\n  const measureStyle = {\n    width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows\n    }),\n    ref: needEllipsisRef\n  }, fullContent), /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows - 1\n    }),\n    ref: descRowsEllipsisRef\n  }, fullContent), /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: 1\n    }),\n    ref: symbolRowEllipsisRef\n  }, children([], true))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign({}, measureStyle), {\n      top: 400\n    }),\n    ref: cutMidRef\n  }, children(sliceNodes(nodeList, cutMidIndex), true)));\n}","map":{"version":3,"sources":["C:/Users/ASUS/Documents/Music/node_modules/antd/es/typography/Base/Ellipsis.js"],"names":["_toConsumableArray","React","toArray","useLayoutEffect","MeasureText","forwardRef","_ref","ref","style","children","spanRef","useRef","useImperativeHandle","isExceed","span","current","scrollHeight","clientHeight","getHeight","createElement","Object","assign","position","display","left","top","pointerEvents","backgroundColor","cuttable","node","type","getNodesLen","nodeList","totalLen","forEach","String","length","sliceNodes","len","currLen","currentNodeList","i","canCut","nodeLen","nextLen","restLen","push","slice","STATUS_MEASURE_NONE","STATUS_MEASURE_START","STATUS_MEASURE_NEED_ELLIPSIS","STATUS_MEASURE_NO_NEED_ELLIPSIS","lineClipStyle","overflow","WebkitBoxOrient","EllipsisMeasure","props","enableMeasure","width","text","rows","expanded","miscDeps","onEllipsis","useMemo","fullContent","ellipsisCutIndex","setEllipsisCutIndex","useState","cutMidRef","needEllipsisRef","descRowsEllipsisRef","symbolRowEllipsisRef","canEllipsis","setCanEllipsis","needEllipsis","setNeedEllipsis","ellipsisHeight","setEllipsisHeight","_a","_b","_c","_d","isOverflow","baseRowsEllipsisHeight","descRowsEllipsisHeight","symbolRowEllipsisHeight","rowsWithEllipsisHeight","maxRowsHeight","Math","max","cutMidIndex","ceil","minIndex","maxIndex","midHeight","targetMidIndex","finalContent","content","WebkitLineClamp","concat","measureStyle","whiteSpace","margin","padding","Fragment"],"mappings":"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","sourcesContent":["\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nconst MeasureText = /*#__PURE__*/React.forwardRef((_ref, ref) => {\n  let {\n    style,\n    children\n  } = _ref;\n  const spanRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => ({\n    isExceed: () => {\n      const span = spanRef.current;\n      return span.scrollHeight > span.clientHeight;\n    },\n    getHeight: () => spanRef.current.clientHeight\n  }));\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": true,\n    ref: spanRef,\n    style: Object.assign({\n      position: 'fixed',\n      display: 'block',\n      left: 0,\n      top: 0,\n      // zIndex: -9999,\n      // visibility: 'hidden',\n      pointerEvents: 'none',\n      backgroundColor: 'rgba(255, 0, 0, 0.65)'\n    }, style)\n  }, children);\n});\nfunction cuttable(node) {\n  const type = typeof node;\n  return type === 'string' || type === 'number';\n}\nfunction getNodesLen(nodeList) {\n  let totalLen = 0;\n  nodeList.forEach(node => {\n    if (cuttable(node)) {\n      totalLen += String(node).length;\n    } else {\n      totalLen += 1;\n    }\n  });\n  return totalLen;\n}\nfunction sliceNodes(nodeList, len) {\n  let currLen = 0;\n  const currentNodeList = [];\n  for (let i = 0; i < nodeList.length; i += 1) {\n    // Match to return\n    if (currLen === len) {\n      return currentNodeList;\n    }\n    const node = nodeList[i];\n    const canCut = cuttable(node);\n    const nodeLen = canCut ? String(node).length : 1;\n    const nextLen = currLen + nodeLen;\n    // Exceed but current not which means we need cut this\n    // This will not happen on validate ReactElement\n    if (nextLen > len) {\n      const restLen = len - currLen;\n      currentNodeList.push(String(node).slice(0, restLen));\n      return currentNodeList;\n    }\n    currentNodeList.push(node);\n    currLen = nextLen;\n  }\n  return nodeList;\n}\n// Measure for the `text` is exceed the `rows` or not\nconst STATUS_MEASURE_NONE = 0;\nconst STATUS_MEASURE_START = 1;\nconst STATUS_MEASURE_NEED_ELLIPSIS = 2;\nconst STATUS_MEASURE_NO_NEED_ELLIPSIS = 3;\nconst lineClipStyle = {\n  display: '-webkit-box',\n  overflow: 'hidden',\n  WebkitBoxOrient: 'vertical'\n};\nexport default function EllipsisMeasure(props) {\n  const {\n    enableMeasure,\n    width,\n    text,\n    children,\n    rows,\n    expanded,\n    miscDeps,\n    onEllipsis\n  } = props;\n  const nodeList = React.useMemo(() => toArray(text), [text]);\n  const nodeLen = React.useMemo(() => getNodesLen(nodeList), [text]);\n  // ========================= Full Content =========================\n  // Used for measure only, which means it's always render as no need ellipsis\n  const fullContent = React.useMemo(() => children(nodeList, false), [text]);\n  // ========================= Cut Content ==========================\n  const [ellipsisCutIndex, setEllipsisCutIndex] = React.useState(null);\n  const cutMidRef = React.useRef(null);\n  // ========================= NeedEllipsis =========================\n  const needEllipsisRef = React.useRef(null);\n  // Measure for `rows-1` height, to avoid operation exceed the line height\n  const descRowsEllipsisRef = React.useRef(null);\n  const symbolRowEllipsisRef = React.useRef(null);\n  const [canEllipsis, setCanEllipsis] = React.useState(false);\n  const [needEllipsis, setNeedEllipsis] = React.useState(STATUS_MEASURE_NONE);\n  const [ellipsisHeight, setEllipsisHeight] = React.useState(0);\n  // Trigger start measure\n  useLayoutEffect(() => {\n    if (enableMeasure && width && nodeLen) {\n      setNeedEllipsis(STATUS_MEASURE_START);\n    } else {\n      setNeedEllipsis(STATUS_MEASURE_NONE);\n    }\n  }, [width, text, rows, enableMeasure, nodeList]);\n  // Measure process\n  useLayoutEffect(() => {\n    var _a, _b, _c, _d;\n    if (needEllipsis === STATUS_MEASURE_START) {\n      const isOverflow = !!((_a = needEllipsisRef.current) === null || _a === void 0 ? void 0 : _a.isExceed());\n      setNeedEllipsis(isOverflow ? STATUS_MEASURE_NEED_ELLIPSIS : STATUS_MEASURE_NO_NEED_ELLIPSIS);\n      setEllipsisCutIndex(isOverflow ? [0, nodeLen] : null);\n      setCanEllipsis(isOverflow);\n      // Get the basic height of ellipsis rows\n      const baseRowsEllipsisHeight = ((_b = needEllipsisRef.current) === null || _b === void 0 ? void 0 : _b.getHeight()) || 0;\n      // Get the height of `rows - 1` + symbol height\n      const descRowsEllipsisHeight = rows === 1 ? 0 : ((_c = descRowsEllipsisRef.current) === null || _c === void 0 ? void 0 : _c.getHeight()) || 0;\n      const symbolRowEllipsisHeight = ((_d = symbolRowEllipsisRef.current) === null || _d === void 0 ? void 0 : _d.getHeight()) || 0;\n      const rowsWithEllipsisHeight = descRowsEllipsisHeight + symbolRowEllipsisHeight;\n      const maxRowsHeight = Math.max(baseRowsEllipsisHeight, rowsWithEllipsisHeight);\n      setEllipsisHeight(maxRowsHeight + 1);\n      onEllipsis(isOverflow);\n    }\n  }, [needEllipsis]);\n  // ========================= Cut Measure ==========================\n  const cutMidIndex = ellipsisCutIndex ? Math.ceil((ellipsisCutIndex[0] + ellipsisCutIndex[1]) / 2) : 0;\n  useLayoutEffect(() => {\n    var _a;\n    const [minIndex, maxIndex] = ellipsisCutIndex || [0, 0];\n    if (minIndex !== maxIndex) {\n      const midHeight = ((_a = cutMidRef.current) === null || _a === void 0 ? void 0 : _a.getHeight()) || 0;\n      const isOverflow = midHeight > ellipsisHeight;\n      let targetMidIndex = cutMidIndex;\n      if (maxIndex - minIndex === 1) {\n        targetMidIndex = isOverflow ? minIndex : maxIndex;\n      }\n      if (isOverflow) {\n        setEllipsisCutIndex([minIndex, targetMidIndex]);\n      } else {\n        setEllipsisCutIndex([targetMidIndex, maxIndex]);\n      }\n    }\n  }, [ellipsisCutIndex, cutMidIndex]);\n  // ========================= Text Content =========================\n  const finalContent = React.useMemo(() => {\n    if (needEllipsis !== STATUS_MEASURE_NEED_ELLIPSIS || !ellipsisCutIndex || ellipsisCutIndex[0] !== ellipsisCutIndex[1]) {\n      const content = children(nodeList, false);\n      // Limit the max line count to avoid scrollbar blink\n      // https://github.com/ant-design/ant-design/issues/42958\n      if (needEllipsis !== STATUS_MEASURE_NO_NEED_ELLIPSIS && needEllipsis !== STATUS_MEASURE_NONE) {\n        return /*#__PURE__*/React.createElement(\"span\", {\n          style: Object.assign(Object.assign({}, lineClipStyle), {\n            WebkitLineClamp: rows\n          })\n        }, content);\n      }\n      return content;\n    }\n    return children(expanded ? nodeList : sliceNodes(nodeList, ellipsisCutIndex[0]), canEllipsis);\n  }, [expanded, needEllipsis, ellipsisCutIndex, nodeList].concat(_toConsumableArray(miscDeps)));\n  // ============================ Render ============================\n  const measureStyle = {\n    width,\n    whiteSpace: 'normal',\n    margin: 0,\n    padding: 0\n  };\n  return /*#__PURE__*/React.createElement(React.Fragment, null, finalContent, needEllipsis === STATUS_MEASURE_START && ( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows\n    }),\n    ref: needEllipsisRef\n  }, fullContent), /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: rows - 1\n    }),\n    ref: descRowsEllipsisRef\n  }, fullContent), /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign(Object.assign({}, measureStyle), lineClipStyle), {\n      WebkitLineClamp: 1\n    }),\n    ref: symbolRowEllipsisRef\n  }, children([], true)))), needEllipsis === STATUS_MEASURE_NEED_ELLIPSIS && ellipsisCutIndex && ellipsisCutIndex[0] !== ellipsisCutIndex[1] && ( /*#__PURE__*/React.createElement(MeasureText, {\n    style: Object.assign(Object.assign({}, measureStyle), {\n      top: 400\n    }),\n    ref: cutMidRef\n  }, children(sliceNodes(nodeList, cutMidIndex), true))));\n}"]},"metadata":{},"sourceType":"module"}