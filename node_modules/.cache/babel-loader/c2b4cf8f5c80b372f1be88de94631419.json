{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport KeyCode from \"rc-util/es/KeyCode\";\nimport * as React from 'react';\nimport { SEARCH_MARK } from \"../hooks/useSearchOptions\";\nimport { getFullPathKeys, toPathKey } from \"../utils/commonUtil\";\nexport default (function (ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) {\n  var direction = contextProps.direction,\n      searchValue = contextProps.searchValue,\n      toggleOpen = contextProps.toggleOpen,\n      open = contextProps.open;\n  var rtl = direction === 'rtl';\n\n  var _React$useMemo = React.useMemo(function () {\n    var activeIndex = -1;\n    var currentOptions = options;\n    var mergedActiveIndexes = [];\n    var mergedActiveValueCells = [];\n    var len = activeValueCells.length;\n    var pathKeys = getFullPathKeys(options, fieldNames); // Fill validate active value cells and index\n\n    var _loop = function _loop(i) {\n      // Mark the active index for current options\n      var nextActiveIndex = currentOptions.findIndex(function (option, index) {\n        return (pathKeys[index] ? toPathKey(pathKeys[index]) : option[fieldNames.value]) === activeValueCells[i];\n      });\n\n      if (nextActiveIndex === -1) {\n        return 1; // break\n      }\n\n      activeIndex = nextActiveIndex;\n      mergedActiveIndexes.push(activeIndex);\n      mergedActiveValueCells.push(activeValueCells[i]);\n      currentOptions = currentOptions[activeIndex][fieldNames.children];\n    };\n\n    for (var i = 0; i < len && currentOptions; i += 1) {\n      if (_loop(i)) break;\n    } // Fill last active options\n\n\n    var activeOptions = options;\n\n    for (var _i = 0; _i < mergedActiveIndexes.length - 1; _i += 1) {\n      activeOptions = activeOptions[mergedActiveIndexes[_i]][fieldNames.children];\n    }\n\n    return [mergedActiveValueCells, activeIndex, activeOptions, pathKeys];\n  }, [activeValueCells, fieldNames, options]),\n      _React$useMemo2 = _slicedToArray(_React$useMemo, 4),\n      validActiveValueCells = _React$useMemo2[0],\n      lastActiveIndex = _React$useMemo2[1],\n      lastActiveOptions = _React$useMemo2[2],\n      fullPathKeys = _React$useMemo2[3]; // Update active value cells and scroll to target element\n\n\n  var internalSetActiveValueCells = function internalSetActiveValueCells(next) {\n    setActiveValueCells(next);\n  }; // Same options offset\n\n\n  var offsetActiveOption = function offsetActiveOption(offset) {\n    var len = lastActiveOptions.length;\n    var currentIndex = lastActiveIndex;\n\n    if (currentIndex === -1 && offset < 0) {\n      currentIndex = len;\n    }\n\n    for (var i = 0; i < len; i += 1) {\n      currentIndex = (currentIndex + offset + len) % len;\n      var _option = lastActiveOptions[currentIndex];\n\n      if (_option && !_option.disabled) {\n        var nextActiveCells = validActiveValueCells.slice(0, -1).concat(fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : _option[fieldNames.value]);\n        internalSetActiveValueCells(nextActiveCells);\n        return;\n      }\n    }\n  }; // Different options offset\n\n\n  var prevColumn = function prevColumn() {\n    if (validActiveValueCells.length > 1) {\n      var nextActiveCells = validActiveValueCells.slice(0, -1);\n      internalSetActiveValueCells(nextActiveCells);\n    } else {\n      toggleOpen(false);\n    }\n  };\n\n  var nextColumn = function nextColumn() {\n    var _lastActiveOptions$la;\n\n    var nextOptions = ((_lastActiveOptions$la = lastActiveOptions[lastActiveIndex]) === null || _lastActiveOptions$la === void 0 ? void 0 : _lastActiveOptions$la[fieldNames.children]) || [];\n    var nextOption = nextOptions.find(function (option) {\n      return !option.disabled;\n    });\n\n    if (nextOption) {\n      var nextActiveCells = [].concat(_toConsumableArray(validActiveValueCells), [nextOption[fieldNames.value]]);\n      internalSetActiveValueCells(nextActiveCells);\n    }\n  };\n\n  React.useImperativeHandle(ref, function () {\n    return {\n      // scrollTo: treeRef.current?.scrollTo,\n      onKeyDown: function onKeyDown(event) {\n        var which = event.which;\n\n        switch (which) {\n          // >>> Arrow keys\n          case KeyCode.UP:\n          case KeyCode.DOWN:\n            {\n              var offset = 0;\n\n              if (which === KeyCode.UP) {\n                offset = -1;\n              } else if (which === KeyCode.DOWN) {\n                offset = 1;\n              }\n\n              if (offset !== 0) {\n                offsetActiveOption(offset);\n              }\n\n              break;\n            }\n\n          case KeyCode.LEFT:\n            {\n              if (searchValue) {\n                break;\n              }\n\n              if (rtl) {\n                nextColumn();\n              } else {\n                prevColumn();\n              }\n\n              break;\n            }\n\n          case KeyCode.RIGHT:\n            {\n              if (searchValue) {\n                break;\n              }\n\n              if (rtl) {\n                prevColumn();\n              } else {\n                nextColumn();\n              }\n\n              break;\n            }\n\n          case KeyCode.BACKSPACE:\n            {\n              if (!searchValue) {\n                prevColumn();\n              }\n\n              break;\n            }\n          // >>> Select\n\n          case KeyCode.ENTER:\n            {\n              if (validActiveValueCells.length) {\n                var _option2 = lastActiveOptions[lastActiveIndex]; // Search option should revert back of origin options\n\n                var originOptions = (_option2 === null || _option2 === void 0 ? void 0 : _option2[SEARCH_MARK]) || [];\n\n                if (originOptions.length) {\n                  onKeyBoardSelect(originOptions.map(function (opt) {\n                    return opt[fieldNames.value];\n                  }), originOptions[originOptions.length - 1]);\n                } else {\n                  onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);\n                }\n              }\n\n              break;\n            }\n          // >>> Close\n\n          case KeyCode.ESC:\n            {\n              toggleOpen(false);\n\n              if (open) {\n                event.stopPropagation();\n              }\n            }\n        }\n      },\n      onKeyUp: function onKeyUp() {}\n    };\n  });\n});","map":{"version":3,"sources":["D:/WED/SpotifyProject-master/node_modules/rc-cascader/es/OptionList/useKeyboard.js"],"names":["_toConsumableArray","_slicedToArray","KeyCode","React","SEARCH_MARK","getFullPathKeys","toPathKey","ref","options","fieldNames","activeValueCells","setActiveValueCells","onKeyBoardSelect","contextProps","direction","searchValue","toggleOpen","open","rtl","_React$useMemo","useMemo","activeIndex","currentOptions","mergedActiveIndexes","mergedActiveValueCells","len","length","pathKeys","_loop","i","nextActiveIndex","findIndex","option","index","value","push","children","activeOptions","_i","_React$useMemo2","validActiveValueCells","lastActiveIndex","lastActiveOptions","fullPathKeys","internalSetActiveValueCells","next","offsetActiveOption","offset","currentIndex","_option","disabled","nextActiveCells","slice","concat","prevColumn","nextColumn","_lastActiveOptions$la","nextOptions","nextOption","find","useImperativeHandle","onKeyDown","event","which","UP","DOWN","LEFT","RIGHT","BACKSPACE","ENTER","_option2","originOptions","map","opt","ESC","stopPropagation","onKeyUp"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport KeyCode from \"rc-util/es/KeyCode\";\nimport * as React from 'react';\nimport { SEARCH_MARK } from \"../hooks/useSearchOptions\";\nimport { getFullPathKeys, toPathKey } from \"../utils/commonUtil\";\nexport default (function (ref, options, fieldNames, activeValueCells, setActiveValueCells, onKeyBoardSelect, contextProps) {\n  var direction = contextProps.direction,\n    searchValue = contextProps.searchValue,\n    toggleOpen = contextProps.toggleOpen,\n    open = contextProps.open;\n  var rtl = direction === 'rtl';\n  var _React$useMemo = React.useMemo(function () {\n      var activeIndex = -1;\n      var currentOptions = options;\n      var mergedActiveIndexes = [];\n      var mergedActiveValueCells = [];\n      var len = activeValueCells.length;\n      var pathKeys = getFullPathKeys(options, fieldNames);\n\n      // Fill validate active value cells and index\n      var _loop = function _loop(i) {\n        // Mark the active index for current options\n        var nextActiveIndex = currentOptions.findIndex(function (option, index) {\n          return (pathKeys[index] ? toPathKey(pathKeys[index]) : option[fieldNames.value]) === activeValueCells[i];\n        });\n        if (nextActiveIndex === -1) {\n          return 1; // break\n        }\n        activeIndex = nextActiveIndex;\n        mergedActiveIndexes.push(activeIndex);\n        mergedActiveValueCells.push(activeValueCells[i]);\n        currentOptions = currentOptions[activeIndex][fieldNames.children];\n      };\n      for (var i = 0; i < len && currentOptions; i += 1) {\n        if (_loop(i)) break;\n      }\n\n      // Fill last active options\n      var activeOptions = options;\n      for (var _i = 0; _i < mergedActiveIndexes.length - 1; _i += 1) {\n        activeOptions = activeOptions[mergedActiveIndexes[_i]][fieldNames.children];\n      }\n      return [mergedActiveValueCells, activeIndex, activeOptions, pathKeys];\n    }, [activeValueCells, fieldNames, options]),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 4),\n    validActiveValueCells = _React$useMemo2[0],\n    lastActiveIndex = _React$useMemo2[1],\n    lastActiveOptions = _React$useMemo2[2],\n    fullPathKeys = _React$useMemo2[3];\n\n  // Update active value cells and scroll to target element\n  var internalSetActiveValueCells = function internalSetActiveValueCells(next) {\n    setActiveValueCells(next);\n  };\n\n  // Same options offset\n  var offsetActiveOption = function offsetActiveOption(offset) {\n    var len = lastActiveOptions.length;\n    var currentIndex = lastActiveIndex;\n    if (currentIndex === -1 && offset < 0) {\n      currentIndex = len;\n    }\n    for (var i = 0; i < len; i += 1) {\n      currentIndex = (currentIndex + offset + len) % len;\n      var _option = lastActiveOptions[currentIndex];\n      if (_option && !_option.disabled) {\n        var nextActiveCells = validActiveValueCells.slice(0, -1).concat(fullPathKeys[currentIndex] ? toPathKey(fullPathKeys[currentIndex]) : _option[fieldNames.value]);\n        internalSetActiveValueCells(nextActiveCells);\n        return;\n      }\n    }\n  };\n\n  // Different options offset\n  var prevColumn = function prevColumn() {\n    if (validActiveValueCells.length > 1) {\n      var nextActiveCells = validActiveValueCells.slice(0, -1);\n      internalSetActiveValueCells(nextActiveCells);\n    } else {\n      toggleOpen(false);\n    }\n  };\n  var nextColumn = function nextColumn() {\n    var _lastActiveOptions$la;\n    var nextOptions = ((_lastActiveOptions$la = lastActiveOptions[lastActiveIndex]) === null || _lastActiveOptions$la === void 0 ? void 0 : _lastActiveOptions$la[fieldNames.children]) || [];\n    var nextOption = nextOptions.find(function (option) {\n      return !option.disabled;\n    });\n    if (nextOption) {\n      var nextActiveCells = [].concat(_toConsumableArray(validActiveValueCells), [nextOption[fieldNames.value]]);\n      internalSetActiveValueCells(nextActiveCells);\n    }\n  };\n  React.useImperativeHandle(ref, function () {\n    return {\n      // scrollTo: treeRef.current?.scrollTo,\n      onKeyDown: function onKeyDown(event) {\n        var which = event.which;\n        switch (which) {\n          // >>> Arrow keys\n          case KeyCode.UP:\n          case KeyCode.DOWN:\n            {\n              var offset = 0;\n              if (which === KeyCode.UP) {\n                offset = -1;\n              } else if (which === KeyCode.DOWN) {\n                offset = 1;\n              }\n              if (offset !== 0) {\n                offsetActiveOption(offset);\n              }\n              break;\n            }\n          case KeyCode.LEFT:\n            {\n              if (searchValue) {\n                break;\n              }\n              if (rtl) {\n                nextColumn();\n              } else {\n                prevColumn();\n              }\n              break;\n            }\n          case KeyCode.RIGHT:\n            {\n              if (searchValue) {\n                break;\n              }\n              if (rtl) {\n                prevColumn();\n              } else {\n                nextColumn();\n              }\n              break;\n            }\n          case KeyCode.BACKSPACE:\n            {\n              if (!searchValue) {\n                prevColumn();\n              }\n              break;\n            }\n\n          // >>> Select\n          case KeyCode.ENTER:\n            {\n              if (validActiveValueCells.length) {\n                var _option2 = lastActiveOptions[lastActiveIndex];\n\n                // Search option should revert back of origin options\n                var originOptions = (_option2 === null || _option2 === void 0 ? void 0 : _option2[SEARCH_MARK]) || [];\n                if (originOptions.length) {\n                  onKeyBoardSelect(originOptions.map(function (opt) {\n                    return opt[fieldNames.value];\n                  }), originOptions[originOptions.length - 1]);\n                } else {\n                  onKeyBoardSelect(validActiveValueCells, lastActiveOptions[lastActiveIndex]);\n                }\n              }\n              break;\n            }\n\n          // >>> Close\n          case KeyCode.ESC:\n            {\n              toggleOpen(false);\n              if (open) {\n                event.stopPropagation();\n              }\n            }\n        }\n      },\n      onKeyUp: function onKeyUp() {}\n    };\n  });\n});"]},"metadata":{},"sourceType":"module"}