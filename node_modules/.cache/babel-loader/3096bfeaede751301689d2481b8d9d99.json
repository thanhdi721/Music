{"ast":null,"code":"import { getArrowOffsetToken } from '../style/placementArrow';\nexport function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow) {\n  if (autoAdjustOverflow === false) {\n    return {\n      adjustX: false,\n      adjustY: false\n    };\n  }\n\n  const overflow = autoAdjustOverflow && typeof autoAdjustOverflow === 'object' ? autoAdjustOverflow : {};\n  const baseOverflow = {};\n\n  switch (placement) {\n    case 'top':\n    case 'bottom':\n      baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;\n      baseOverflow.shiftY = true;\n      baseOverflow.adjustY = true;\n      break;\n\n    case 'left':\n    case 'right':\n      baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;\n      baseOverflow.shiftX = true;\n      baseOverflow.adjustX = true;\n      break;\n  }\n\n  const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow); // Support auto shift\n\n  if (!mergedOverflow.shiftX) {\n    mergedOverflow.adjustX = true;\n  }\n\n  if (!mergedOverflow.shiftY) {\n    mergedOverflow.adjustY = true;\n  }\n\n  return mergedOverflow;\n}\nconst PlacementAlignMap = {\n  left: {\n    points: ['cr', 'cl']\n  },\n  right: {\n    points: ['cl', 'cr']\n  },\n  top: {\n    points: ['bc', 'tc']\n  },\n  bottom: {\n    points: ['tc', 'bc']\n  },\n  topLeft: {\n    points: ['bl', 'tl']\n  },\n  leftTop: {\n    points: ['tr', 'tl']\n  },\n  topRight: {\n    points: ['br', 'tr']\n  },\n  rightTop: {\n    points: ['tl', 'tr']\n  },\n  bottomRight: {\n    points: ['tr', 'br']\n  },\n  rightBottom: {\n    points: ['bl', 'br']\n  },\n  bottomLeft: {\n    points: ['tl', 'bl']\n  },\n  leftBottom: {\n    points: ['br', 'bl']\n  }\n};\nconst ArrowCenterPlacementAlignMap = {\n  topLeft: {\n    points: ['bl', 'tc']\n  },\n  leftTop: {\n    points: ['tr', 'cl']\n  },\n  topRight: {\n    points: ['br', 'tc']\n  },\n  rightTop: {\n    points: ['tl', 'cr']\n  },\n  bottomRight: {\n    points: ['tr', 'bc']\n  },\n  rightBottom: {\n    points: ['bl', 'cr']\n  },\n  bottomLeft: {\n    points: ['tl', 'bc']\n  },\n  leftBottom: {\n    points: ['br', 'cl']\n  }\n};\nconst DisableAutoArrowList = new Set(['topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'leftTop', 'leftBottom', 'rightTop', 'rightBottom']);\nexport default function getPlacements(config) {\n  const {\n    arrowWidth,\n    autoAdjustOverflow,\n    arrowPointAtCenter,\n    offset,\n    borderRadius,\n    visibleFirst\n  } = config;\n  const halfArrowWidth = arrowWidth / 2;\n  const placementMap = {};\n  Object.keys(PlacementAlignMap).forEach(key => {\n    const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];\n    const placementInfo = Object.assign(Object.assign({}, template), {\n      offset: [0, 0],\n      dynamicInset: true\n    });\n    placementMap[key] = placementInfo; // Disable autoArrow since design is fixed position\n\n    if (DisableAutoArrowList.has(key)) {\n      placementInfo.autoArrow = false;\n    } // Static offset\n\n\n    switch (key) {\n      case 'top':\n      case 'topLeft':\n      case 'topRight':\n        placementInfo.offset[1] = -halfArrowWidth - offset;\n        break;\n\n      case 'bottom':\n      case 'bottomLeft':\n      case 'bottomRight':\n        placementInfo.offset[1] = halfArrowWidth + offset;\n        break;\n\n      case 'left':\n      case 'leftTop':\n      case 'leftBottom':\n        placementInfo.offset[0] = -halfArrowWidth - offset;\n        break;\n\n      case 'right':\n      case 'rightTop':\n      case 'rightBottom':\n        placementInfo.offset[0] = halfArrowWidth + offset;\n        break;\n    } // Dynamic offset\n\n\n    const arrowOffset = getArrowOffsetToken({\n      contentRadius: borderRadius,\n      limitVerticalRadius: true\n    });\n\n    if (arrowPointAtCenter) {\n      switch (key) {\n        case 'topLeft':\n        case 'bottomLeft':\n          placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;\n          break;\n\n        case 'topRight':\n        case 'bottomRight':\n          placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;\n          break;\n\n        case 'leftTop':\n        case 'rightTop':\n          placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;\n          break;\n\n        case 'leftBottom':\n        case 'rightBottom':\n          placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;\n          break;\n      }\n    } // Overflow\n\n\n    placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow); // VisibleFirst\n\n    if (visibleFirst) {\n      placementInfo.htmlRegion = 'visibleFirst';\n    }\n  });\n  return placementMap;\n}","map":{"version":3,"sources":["C:/Users/ASUS/Documents/Music/node_modules/antd/es/_util/placements.js"],"names":["getArrowOffsetToken","getOverflowOptions","placement","arrowOffset","arrowWidth","autoAdjustOverflow","adjustX","adjustY","overflow","baseOverflow","shiftX","arrowOffsetHorizontal","shiftY","arrowOffsetVertical","mergedOverflow","Object","assign","PlacementAlignMap","left","points","right","top","bottom","topLeft","leftTop","topRight","rightTop","bottomRight","rightBottom","bottomLeft","leftBottom","ArrowCenterPlacementAlignMap","DisableAutoArrowList","Set","getPlacements","config","arrowPointAtCenter","offset","borderRadius","visibleFirst","halfArrowWidth","placementMap","keys","forEach","key","template","placementInfo","dynamicInset","has","autoArrow","contentRadius","limitVerticalRadius","htmlRegion"],"mappings":"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","sourcesContent":["import { getArrowOffsetToken } from '../style/placementArrow';\nexport function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow) {\n  if (autoAdjustOverflow === false) {\n    return {\n      adjustX: false,\n      adjustY: false\n    };\n  }\n  const overflow = autoAdjustOverflow && typeof autoAdjustOverflow === 'object' ? autoAdjustOverflow : {};\n  const baseOverflow = {};\n  switch (placement) {\n    case 'top':\n    case 'bottom':\n      baseOverflow.shiftX = arrowOffset.arrowOffsetHorizontal * 2 + arrowWidth;\n      baseOverflow.shiftY = true;\n      baseOverflow.adjustY = true;\n      break;\n    case 'left':\n    case 'right':\n      baseOverflow.shiftY = arrowOffset.arrowOffsetVertical * 2 + arrowWidth;\n      baseOverflow.shiftX = true;\n      baseOverflow.adjustX = true;\n      break;\n  }\n  const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);\n  // Support auto shift\n  if (!mergedOverflow.shiftX) {\n    mergedOverflow.adjustX = true;\n  }\n  if (!mergedOverflow.shiftY) {\n    mergedOverflow.adjustY = true;\n  }\n  return mergedOverflow;\n}\nconst PlacementAlignMap = {\n  left: {\n    points: ['cr', 'cl']\n  },\n  right: {\n    points: ['cl', 'cr']\n  },\n  top: {\n    points: ['bc', 'tc']\n  },\n  bottom: {\n    points: ['tc', 'bc']\n  },\n  topLeft: {\n    points: ['bl', 'tl']\n  },\n  leftTop: {\n    points: ['tr', 'tl']\n  },\n  topRight: {\n    points: ['br', 'tr']\n  },\n  rightTop: {\n    points: ['tl', 'tr']\n  },\n  bottomRight: {\n    points: ['tr', 'br']\n  },\n  rightBottom: {\n    points: ['bl', 'br']\n  },\n  bottomLeft: {\n    points: ['tl', 'bl']\n  },\n  leftBottom: {\n    points: ['br', 'bl']\n  }\n};\nconst ArrowCenterPlacementAlignMap = {\n  topLeft: {\n    points: ['bl', 'tc']\n  },\n  leftTop: {\n    points: ['tr', 'cl']\n  },\n  topRight: {\n    points: ['br', 'tc']\n  },\n  rightTop: {\n    points: ['tl', 'cr']\n  },\n  bottomRight: {\n    points: ['tr', 'bc']\n  },\n  rightBottom: {\n    points: ['bl', 'cr']\n  },\n  bottomLeft: {\n    points: ['tl', 'bc']\n  },\n  leftBottom: {\n    points: ['br', 'cl']\n  }\n};\nconst DisableAutoArrowList = new Set(['topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'leftTop', 'leftBottom', 'rightTop', 'rightBottom']);\nexport default function getPlacements(config) {\n  const {\n    arrowWidth,\n    autoAdjustOverflow,\n    arrowPointAtCenter,\n    offset,\n    borderRadius,\n    visibleFirst\n  } = config;\n  const halfArrowWidth = arrowWidth / 2;\n  const placementMap = {};\n  Object.keys(PlacementAlignMap).forEach(key => {\n    const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];\n    const placementInfo = Object.assign(Object.assign({}, template), {\n      offset: [0, 0],\n      dynamicInset: true\n    });\n    placementMap[key] = placementInfo;\n    // Disable autoArrow since design is fixed position\n    if (DisableAutoArrowList.has(key)) {\n      placementInfo.autoArrow = false;\n    }\n    // Static offset\n    switch (key) {\n      case 'top':\n      case 'topLeft':\n      case 'topRight':\n        placementInfo.offset[1] = -halfArrowWidth - offset;\n        break;\n      case 'bottom':\n      case 'bottomLeft':\n      case 'bottomRight':\n        placementInfo.offset[1] = halfArrowWidth + offset;\n        break;\n      case 'left':\n      case 'leftTop':\n      case 'leftBottom':\n        placementInfo.offset[0] = -halfArrowWidth - offset;\n        break;\n      case 'right':\n      case 'rightTop':\n      case 'rightBottom':\n        placementInfo.offset[0] = halfArrowWidth + offset;\n        break;\n    }\n    // Dynamic offset\n    const arrowOffset = getArrowOffsetToken({\n      contentRadius: borderRadius,\n      limitVerticalRadius: true\n    });\n    if (arrowPointAtCenter) {\n      switch (key) {\n        case 'topLeft':\n        case 'bottomLeft':\n          placementInfo.offset[0] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;\n          break;\n        case 'topRight':\n        case 'bottomRight':\n          placementInfo.offset[0] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;\n          break;\n        case 'leftTop':\n        case 'rightTop':\n          placementInfo.offset[1] = -arrowOffset.arrowOffsetHorizontal - halfArrowWidth;\n          break;\n        case 'leftBottom':\n        case 'rightBottom':\n          placementInfo.offset[1] = arrowOffset.arrowOffsetHorizontal + halfArrowWidth;\n          break;\n      }\n    }\n    // Overflow\n    placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow);\n    // VisibleFirst\n    if (visibleFirst) {\n      placementInfo.htmlRegion = 'visibleFirst';\n    }\n  });\n  return placementMap;\n}"]},"metadata":{},"sourceType":"module"}