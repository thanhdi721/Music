{"ast":null,"code":"export const FontGap = 3;\n\nfunction prepareCanvas(width, height) {\n  let ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const realWidth = width * ratio;\n  const realHeight = height * ratio;\n  canvas.setAttribute('width', `${realWidth}px`);\n  canvas.setAttribute('height', `${realHeight}px`);\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n}\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\n\n\nexport default function useClips() {\n  // Get single clips\n  function getClips(content, rotate, ratio, width, height, font, gapX, gapY) {\n    // ================= Text / Image =================\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);\n\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      // Text\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign\n      } = font;\n      const mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = 'top';\n      const contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', contentWidth / 2, index * (mergedFontSize + FontGap * ratio));\n      });\n    } // ==================== Rotate ====================\n\n\n    const angle = Math.PI / 180 * Number(rotate);\n    const maxSize = Math.max(width, height);\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio); // Copy from `ctx` and rotate\n\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    } // Get boundary of rotated text\n\n\n    function getRotatePos(x, y) {\n      const targetX = x * Math.cos(angle) - y * Math.sin(angle);\n      const targetY = x * Math.sin(angle) + y * Math.cos(angle);\n      return [targetX, targetY];\n    }\n\n    let left = 0;\n    let right = 0;\n    let top = 0;\n    let bottom = 0;\n    const halfWidth = contentWidth / 2;\n    const halfHeight = contentHeight / 2;\n    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(_ref => {\n      let [x, y] = _ref;\n      const [targetX, targetY] = getRotatePos(x, y);\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    const cutLeft = left + realMaxSize / 2;\n    const cutTop = top + realMaxSize / 2;\n    const cutWidth = right - left;\n    const cutHeight = bottom - top; // ================ Fill Alternate ================\n\n    const realGapX = gapX * ratio;\n    const realGapY = gapY * ratio;\n    const filledWidth = (cutWidth + realGapX) * 2;\n    const filledHeight = cutHeight + realGapY;\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);\n\n    function drawImg() {\n      let targetX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      let targetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);\n    }\n\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  }\n\n  return getClips;\n}","map":{"version":3,"sources":["C:/Users/ASUS/Documents/Music/node_modules/antd/es/watermark/useClips.js"],"names":["FontGap","prepareCanvas","width","height","ratio","arguments","length","undefined","canvas","document","createElement","ctx","getContext","realWidth","realHeight","setAttribute","save","useClips","getClips","content","rotate","font","gapX","gapY","contentWidth","contentHeight","HTMLImageElement","drawImage","color","fontSize","fontStyle","fontWeight","fontFamily","textAlign","mergedFontSize","Number","fillStyle","textBaseline","contents","Array","isArray","forEach","item","index","fillText","angle","Math","PI","maxSize","max","rCtx","rCanvas","realMaxSize","translate","getRotatePos","x","y","targetX","cos","sin","targetY","left","right","top","bottom","halfWidth","halfHeight","points","_ref","min","cutLeft","cutTop","cutWidth","cutHeight","realGapX","realGapY","filledWidth","filledHeight","fCtx","fCanvas","drawImg","toDataURL"],"mappings":"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","sourcesContent":["export const FontGap = 3;\nfunction prepareCanvas(width, height) {\n  let ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const realWidth = width * ratio;\n  const realHeight = height * ratio;\n  canvas.setAttribute('width', `${realWidth}px`);\n  canvas.setAttribute('height', `${realHeight}px`);\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n}\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\nexport default function useClips() {\n  // Get single clips\n  function getClips(content, rotate, ratio, width, height, font, gapX, gapY) {\n    // ================= Text / Image =================\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      // Text\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign\n      } = font;\n      const mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = 'top';\n      const contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', contentWidth / 2, index * (mergedFontSize + FontGap * ratio));\n      });\n    }\n    // ==================== Rotate ====================\n    const angle = Math.PI / 180 * Number(rotate);\n    const maxSize = Math.max(width, height);\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);\n    // Copy from `ctx` and rotate\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    }\n    // Get boundary of rotated text\n    function getRotatePos(x, y) {\n      const targetX = x * Math.cos(angle) - y * Math.sin(angle);\n      const targetY = x * Math.sin(angle) + y * Math.cos(angle);\n      return [targetX, targetY];\n    }\n    let left = 0;\n    let right = 0;\n    let top = 0;\n    let bottom = 0;\n    const halfWidth = contentWidth / 2;\n    const halfHeight = contentHeight / 2;\n    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(_ref => {\n      let [x, y] = _ref;\n      const [targetX, targetY] = getRotatePos(x, y);\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    const cutLeft = left + realMaxSize / 2;\n    const cutTop = top + realMaxSize / 2;\n    const cutWidth = right - left;\n    const cutHeight = bottom - top;\n    // ================ Fill Alternate ================\n    const realGapX = gapX * ratio;\n    const realGapY = gapY * ratio;\n    const filledWidth = (cutWidth + realGapX) * 2;\n    const filledHeight = cutHeight + realGapY;\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);\n    function drawImg() {\n      let targetX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      let targetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);\n    }\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  }\n  return getClips;\n}"]},"metadata":{},"sourceType":"module"}