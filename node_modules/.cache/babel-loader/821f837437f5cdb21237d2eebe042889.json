{"ast":null,"code":"\"use client\";\n\nimport React from 'react';\nimport CloseOutlined from \"@ant-design/icons/es/icons/CloseOutlined\";\nimport pickAttrs from \"rc-util/es/pickAttrs\";\nexport function pickClosable(context) {\n  if (!context) {\n    return undefined;\n  }\n\n  return {\n    closable: context.closable,\n    closeIcon: context.closeIcon\n  };\n}\n/** Convert `closable` and `closeIcon` to config object */\n\nfunction useClosableConfig(closableCollection) {\n  const {\n    closable,\n    closeIcon\n  } = closableCollection || {};\n  return React.useMemo(() => {\n    if ( // If `closable`, whatever rest be should be true\n    !closable && (closable === false || closeIcon === false || closeIcon === null)) {\n      return false;\n    }\n\n    if (closable === undefined && closeIcon === undefined) {\n      return null;\n    }\n\n    let closableConfig = {\n      closeIcon: typeof closeIcon !== 'boolean' && closeIcon !== null ? closeIcon : undefined\n    };\n\n    if (closable && typeof closable === 'object') {\n      closableConfig = Object.assign(Object.assign({}, closableConfig), closable);\n    }\n\n    return closableConfig;\n  }, [closable, closeIcon]);\n}\n/**\n * Assign object without `undefined` field. Will skip if is `false`.\n * This helps to handle both closableConfig or false\n */\n\n\nfunction assignWithoutUndefined() {\n  const target = {};\n\n  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {\n    objList[_key] = arguments[_key];\n  }\n\n  objList.forEach(obj => {\n    if (obj) {\n      Object.keys(obj).forEach(key => {\n        if (obj[key] !== undefined) {\n          target[key] = obj[key];\n        }\n      });\n    }\n  });\n  return target;\n}\n/** Use same object to support `useMemo` optimization */\n\n\nconst EmptyFallbackCloseCollection = {};\nexport default function useClosable(propCloseCollection, contextCloseCollection) {\n  let fallbackCloseCollection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EmptyFallbackCloseCollection; // Align the `props`, `context` `fallback` to config object first\n\n  const propCloseConfig = useClosableConfig(propCloseCollection);\n  const contextCloseConfig = useClosableConfig(contextCloseCollection);\n  const mergedFallbackCloseCollection = React.useMemo(() => Object.assign({\n    closeIcon: /*#__PURE__*/React.createElement(CloseOutlined, null)\n  }, fallbackCloseCollection), [fallbackCloseCollection]); // Use fallback logic to fill the config\n\n  const mergedClosableConfig = React.useMemo(() => {\n    // ================ Props First ================\n    // Skip if prop is disabled\n    if (propCloseConfig === false) {\n      return false;\n    }\n\n    if (propCloseConfig) {\n      return assignWithoutUndefined(mergedFallbackCloseCollection, contextCloseConfig, propCloseConfig);\n    } // =============== Context Second ==============\n    // Skip if context is disabled\n\n\n    if (contextCloseConfig === false) {\n      return false;\n    }\n\n    if (contextCloseConfig) {\n      return assignWithoutUndefined(mergedFallbackCloseCollection, contextCloseConfig);\n    } // ============= Fallback Default ==============\n\n\n    return !mergedFallbackCloseCollection.closable ? false : mergedFallbackCloseCollection;\n  }, [propCloseConfig, contextCloseConfig, mergedFallbackCloseCollection]); // Calculate the final closeIcon\n\n  return React.useMemo(() => {\n    if (mergedClosableConfig === false) {\n      return [false, null];\n    }\n\n    const {\n      closeIconRender\n    } = mergedFallbackCloseCollection;\n    const {\n      closeIcon\n    } = mergedClosableConfig;\n    let mergedCloseIcon = closeIcon;\n\n    if (mergedCloseIcon !== null && mergedCloseIcon !== undefined) {\n      // Wrap the closeIcon if needed\n      if (closeIconRender) {\n        mergedCloseIcon = closeIconRender(closeIcon);\n      } // Wrap the closeIcon with aria props\n\n\n      const ariaProps = pickAttrs(mergedClosableConfig, true);\n\n      if (Object.keys(ariaProps).length) {\n        mergedCloseIcon = /*#__PURE__*/React.isValidElement(mergedCloseIcon) ? /*#__PURE__*/React.cloneElement(mergedCloseIcon, ariaProps) : /*#__PURE__*/React.createElement(\"span\", Object.assign({}, ariaProps), mergedCloseIcon);\n      }\n    }\n\n    return [true, mergedCloseIcon];\n  }, [mergedClosableConfig, mergedFallbackCloseCollection]);\n}","map":{"version":3,"sources":["C:/Users/ASUS/Documents/Music/node_modules/antd/es/_util/hooks/useClosable.js"],"names":["React","CloseOutlined","pickAttrs","pickClosable","context","undefined","closable","closeIcon","useClosableConfig","closableCollection","useMemo","closableConfig","Object","assign","assignWithoutUndefined","target","_len","arguments","length","objList","Array","_key","forEach","obj","keys","key","EmptyFallbackCloseCollection","useClosable","propCloseCollection","contextCloseCollection","fallbackCloseCollection","propCloseConfig","contextCloseConfig","mergedFallbackCloseCollection","createElement","mergedClosableConfig","closeIconRender","mergedCloseIcon","ariaProps","isValidElement","cloneElement"],"mappings":"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","sourcesContent":["\"use client\";\n\nimport React from 'react';\nimport CloseOutlined from \"@ant-design/icons/es/icons/CloseOutlined\";\nimport pickAttrs from \"rc-util/es/pickAttrs\";\nexport function pickClosable(context) {\n  if (!context) {\n    return undefined;\n  }\n  return {\n    closable: context.closable,\n    closeIcon: context.closeIcon\n  };\n}\n/** Convert `closable` and `closeIcon` to config object */\nfunction useClosableConfig(closableCollection) {\n  const {\n    closable,\n    closeIcon\n  } = closableCollection || {};\n  return React.useMemo(() => {\n    if (\n    // If `closable`, whatever rest be should be true\n    !closable && (closable === false || closeIcon === false || closeIcon === null)) {\n      return false;\n    }\n    if (closable === undefined && closeIcon === undefined) {\n      return null;\n    }\n    let closableConfig = {\n      closeIcon: typeof closeIcon !== 'boolean' && closeIcon !== null ? closeIcon : undefined\n    };\n    if (closable && typeof closable === 'object') {\n      closableConfig = Object.assign(Object.assign({}, closableConfig), closable);\n    }\n    return closableConfig;\n  }, [closable, closeIcon]);\n}\n/**\n * Assign object without `undefined` field. Will skip if is `false`.\n * This helps to handle both closableConfig or false\n */\nfunction assignWithoutUndefined() {\n  const target = {};\n  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {\n    objList[_key] = arguments[_key];\n  }\n  objList.forEach(obj => {\n    if (obj) {\n      Object.keys(obj).forEach(key => {\n        if (obj[key] !== undefined) {\n          target[key] = obj[key];\n        }\n      });\n    }\n  });\n  return target;\n}\n/** Use same object to support `useMemo` optimization */\nconst EmptyFallbackCloseCollection = {};\nexport default function useClosable(propCloseCollection, contextCloseCollection) {\n  let fallbackCloseCollection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EmptyFallbackCloseCollection;\n  // Align the `props`, `context` `fallback` to config object first\n  const propCloseConfig = useClosableConfig(propCloseCollection);\n  const contextCloseConfig = useClosableConfig(contextCloseCollection);\n  const mergedFallbackCloseCollection = React.useMemo(() => Object.assign({\n    closeIcon: /*#__PURE__*/React.createElement(CloseOutlined, null)\n  }, fallbackCloseCollection), [fallbackCloseCollection]);\n  // Use fallback logic to fill the config\n  const mergedClosableConfig = React.useMemo(() => {\n    // ================ Props First ================\n    // Skip if prop is disabled\n    if (propCloseConfig === false) {\n      return false;\n    }\n    if (propCloseConfig) {\n      return assignWithoutUndefined(mergedFallbackCloseCollection, contextCloseConfig, propCloseConfig);\n    }\n    // =============== Context Second ==============\n    // Skip if context is disabled\n    if (contextCloseConfig === false) {\n      return false;\n    }\n    if (contextCloseConfig) {\n      return assignWithoutUndefined(mergedFallbackCloseCollection, contextCloseConfig);\n    }\n    // ============= Fallback Default ==============\n    return !mergedFallbackCloseCollection.closable ? false : mergedFallbackCloseCollection;\n  }, [propCloseConfig, contextCloseConfig, mergedFallbackCloseCollection]);\n  // Calculate the final closeIcon\n  return React.useMemo(() => {\n    if (mergedClosableConfig === false) {\n      return [false, null];\n    }\n    const {\n      closeIconRender\n    } = mergedFallbackCloseCollection;\n    const {\n      closeIcon\n    } = mergedClosableConfig;\n    let mergedCloseIcon = closeIcon;\n    if (mergedCloseIcon !== null && mergedCloseIcon !== undefined) {\n      // Wrap the closeIcon if needed\n      if (closeIconRender) {\n        mergedCloseIcon = closeIconRender(closeIcon);\n      }\n      // Wrap the closeIcon with aria props\n      const ariaProps = pickAttrs(mergedClosableConfig, true);\n      if (Object.keys(ariaProps).length) {\n        mergedCloseIcon = /*#__PURE__*/React.isValidElement(mergedCloseIcon) ? ( /*#__PURE__*/React.cloneElement(mergedCloseIcon, ariaProps)) : ( /*#__PURE__*/React.createElement(\"span\", Object.assign({}, ariaProps), mergedCloseIcon));\n      }\n    }\n    return [true, mergedCloseIcon];\n  }, [mergedClosableConfig, mergedFallbackCloseCollection]);\n}"]},"metadata":{},"sourceType":"module"}