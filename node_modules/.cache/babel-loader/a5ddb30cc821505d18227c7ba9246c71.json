{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { pathKey } from \"../Cache\";\nimport StyleContext from \"../StyleContext\";\nimport useCompatibleInsertionEffect from \"./useCompatibleInsertionEffect\";\nimport useEffectCleanupRegister from \"./useEffectCleanupRegister\";\nimport useHMR from \"./useHMR\";\nexport default function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, // Add additional effect trigger by `useInsertionEffect`\nonCacheEffect) {\n  var _React$useContext = React.useContext(StyleContext),\n      globalCache = _React$useContext.cache;\n\n  var fullPath = [prefix].concat(_toConsumableArray(keyPath));\n  var fullPathStr = pathKey(fullPath);\n  var register = useEffectCleanupRegister([fullPathStr]);\n  var HMRUpdate = useHMR();\n\n  var buildCache = function buildCache(updater) {\n    globalCache.opUpdate(fullPathStr, function (prevCache) {\n      var _ref = prevCache || [undefined, undefined],\n          _ref2 = _slicedToArray(_ref, 2),\n          _ref2$ = _ref2[0],\n          times = _ref2$ === void 0 ? 0 : _ref2$,\n          cache = _ref2[1]; // HMR should always ignore cache since developer may change it\n\n\n      var tmpCache = cache;\n\n      if (process.env.NODE_ENV !== 'production' && cache && HMRUpdate) {\n        onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(tmpCache, HMRUpdate);\n        tmpCache = null;\n      }\n\n      var mergedCache = tmpCache || cacheFn();\n      var data = [times, mergedCache]; // Call updater if need additional logic\n\n      return updater ? updater(data) : data;\n    });\n  }; // Create cache\n\n\n  React.useMemo(function () {\n    buildCache();\n  },\n  /* eslint-disable react-hooks/exhaustive-deps */\n  [fullPathStr]\n  /* eslint-enable */\n  );\n  var cacheEntity = globalCache.opGet(fullPathStr); // HMR clean the cache but not trigger `useMemo` again\n  // Let's fallback of this\n  // ref https://github.com/ant-design/cssinjs/issues/127\n\n  if (process.env.NODE_ENV !== 'production' && !cacheEntity) {\n    buildCache();\n    cacheEntity = globalCache.opGet(fullPathStr);\n  }\n\n  var cacheContent = cacheEntity[1]; // Remove if no need anymore\n\n  useCompatibleInsertionEffect(function () {\n    onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);\n  }, function (polyfill) {\n    // It's bad to call build again in effect.\n    // But we have to do this since StrictMode will call effect twice\n    // which will clear cache on the first time.\n    buildCache(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          times = _ref4[0],\n          cache = _ref4[1];\n\n      if (polyfill && times === 0) {\n        onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);\n      }\n\n      return [times + 1, cache];\n    });\n    return function () {\n      globalCache.opUpdate(fullPathStr, function (prevCache) {\n        var _ref5 = prevCache || [],\n            _ref6 = _slicedToArray(_ref5, 2),\n            _ref6$ = _ref6[0],\n            times = _ref6$ === void 0 ? 0 : _ref6$,\n            cache = _ref6[1];\n\n        var nextCount = times - 1;\n\n        if (nextCount === 0) {\n          // Always remove styles in useEffect callback\n          register(function () {\n            // With polyfill, registered callback will always be called synchronously\n            // But without polyfill, it will be called in effect clean up,\n            // And by that time this cache is cleaned up.\n            if (polyfill || !globalCache.opGet(fullPathStr)) {\n              onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(cache, false);\n            }\n          });\n          return null;\n        }\n\n        return [times - 1, cache];\n      });\n    };\n  }, [fullPathStr]);\n  return cacheContent;\n}","map":{"version":3,"sources":["D:/WED/SpotifyProject-master/node_modules/@ant-design/cssinjs/es/hooks/useGlobalCache.js"],"names":["_slicedToArray","_toConsumableArray","React","pathKey","StyleContext","useCompatibleInsertionEffect","useEffectCleanupRegister","useHMR","useGlobalCache","prefix","keyPath","cacheFn","onCacheRemove","onCacheEffect","_React$useContext","useContext","globalCache","cache","fullPath","concat","fullPathStr","register","HMRUpdate","buildCache","updater","opUpdate","prevCache","_ref","undefined","_ref2","_ref2$","times","tmpCache","process","env","NODE_ENV","mergedCache","data","useMemo","cacheEntity","opGet","cacheContent","polyfill","_ref3","_ref4","_ref5","_ref6","_ref6$","nextCount"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,0CAA3B;AACA,OAAOC,kBAAP,MAA+B,8CAA/B;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,OAAT,QAAwB,UAAxB;AACA,OAAOC,YAAP,MAAyB,iBAAzB;AACA,OAAOC,4BAAP,MAAyC,gCAAzC;AACA,OAAOC,wBAAP,MAAqC,4BAArC;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,eAAe,SAASC,cAAT,CAAwBC,MAAxB,EAAgCC,OAAhC,EAAyCC,OAAzC,EAAkDC,aAAlD,EACf;AACAC,aAFe,EAEA;AACb,MAAIC,iBAAiB,GAAGZ,KAAK,CAACa,UAAN,CAAiBX,YAAjB,CAAxB;AAAA,MACEY,WAAW,GAAGF,iBAAiB,CAACG,KADlC;;AAEA,MAAIC,QAAQ,GAAG,CAACT,MAAD,EAASU,MAAT,CAAgBlB,kBAAkB,CAACS,OAAD,CAAlC,CAAf;AACA,MAAIU,WAAW,GAAGjB,OAAO,CAACe,QAAD,CAAzB;AACA,MAAIG,QAAQ,GAAGf,wBAAwB,CAAC,CAACc,WAAD,CAAD,CAAvC;AACA,MAAIE,SAAS,GAAGf,MAAM,EAAtB;;AACA,MAAIgB,UAAU,GAAG,SAASA,UAAT,CAAoBC,OAApB,EAA6B;AAC5CR,IAAAA,WAAW,CAACS,QAAZ,CAAqBL,WAArB,EAAkC,UAAUM,SAAV,EAAqB;AACrD,UAAIC,IAAI,GAAGD,SAAS,IAAI,CAACE,SAAD,EAAYA,SAAZ,CAAxB;AAAA,UACEC,KAAK,GAAG7B,cAAc,CAAC2B,IAAD,EAAO,CAAP,CADxB;AAAA,UAEEG,MAAM,GAAGD,KAAK,CAAC,CAAD,CAFhB;AAAA,UAGEE,KAAK,GAAGD,MAAM,KAAK,KAAK,CAAhB,GAAoB,CAApB,GAAwBA,MAHlC;AAAA,UAIEb,KAAK,GAAGY,KAAK,CAAC,CAAD,CAJf,CADqD,CAOrD;;;AACA,UAAIG,QAAQ,GAAGf,KAAf;;AACA,UAAIgB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyClB,KAAzC,IAAkDK,SAAtD,EAAiE;AAC/DV,QAAAA,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,IAAsDA,aAAa,CAACoB,QAAD,EAAWV,SAAX,CAAnE;AACAU,QAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,UAAII,WAAW,GAAGJ,QAAQ,IAAIrB,OAAO,EAArC;AACA,UAAI0B,IAAI,GAAG,CAACN,KAAD,EAAQK,WAAR,CAAX,CAdqD,CAgBrD;;AACA,aAAOZ,OAAO,GAAGA,OAAO,CAACa,IAAD,CAAV,GAAmBA,IAAjC;AACD,KAlBD;AAmBD,GApBD,CAPa,CA6Bb;;;AACAnC,EAAAA,KAAK,CAACoC,OAAN,CAAc,YAAY;AACxBf,IAAAA,UAAU;AACX,GAFD;AAEG;AACH,GAACH,WAAD;AACA;AAJA;AAMA,MAAImB,WAAW,GAAGvB,WAAW,CAACwB,KAAZ,CAAkBpB,WAAlB,CAAlB,CApCa,CAsCb;AACA;AACA;;AACA,MAAIa,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyC,CAACI,WAA9C,EAA2D;AACzDhB,IAAAA,UAAU;AACVgB,IAAAA,WAAW,GAAGvB,WAAW,CAACwB,KAAZ,CAAkBpB,WAAlB,CAAd;AACD;;AACD,MAAIqB,YAAY,GAAGF,WAAW,CAAC,CAAD,CAA9B,CA7Ca,CA+Cb;;AACAlC,EAAAA,4BAA4B,CAAC,YAAY;AACvCQ,IAAAA,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,IAAsDA,aAAa,CAAC4B,YAAD,CAAnE;AACD,GAF2B,EAEzB,UAAUC,QAAV,EAAoB;AACrB;AACA;AACA;AACAnB,IAAAA,UAAU,CAAC,UAAUoB,KAAV,EAAiB;AAC1B,UAAIC,KAAK,GAAG5C,cAAc,CAAC2C,KAAD,EAAQ,CAAR,CAA1B;AAAA,UACEZ,KAAK,GAAGa,KAAK,CAAC,CAAD,CADf;AAAA,UAEE3B,KAAK,GAAG2B,KAAK,CAAC,CAAD,CAFf;;AAGA,UAAIF,QAAQ,IAAIX,KAAK,KAAK,CAA1B,EAA6B;AAC3BlB,QAAAA,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,IAAsDA,aAAa,CAAC4B,YAAD,CAAnE;AACD;;AACD,aAAO,CAACV,KAAK,GAAG,CAAT,EAAYd,KAAZ,CAAP;AACD,KARS,CAAV;AASA,WAAO,YAAY;AACjBD,MAAAA,WAAW,CAACS,QAAZ,CAAqBL,WAArB,EAAkC,UAAUM,SAAV,EAAqB;AACrD,YAAImB,KAAK,GAAGnB,SAAS,IAAI,EAAzB;AAAA,YACEoB,KAAK,GAAG9C,cAAc,CAAC6C,KAAD,EAAQ,CAAR,CADxB;AAAA,YAEEE,MAAM,GAAGD,KAAK,CAAC,CAAD,CAFhB;AAAA,YAGEf,KAAK,GAAGgB,MAAM,KAAK,KAAK,CAAhB,GAAoB,CAApB,GAAwBA,MAHlC;AAAA,YAIE9B,KAAK,GAAG6B,KAAK,CAAC,CAAD,CAJf;;AAKA,YAAIE,SAAS,GAAGjB,KAAK,GAAG,CAAxB;;AACA,YAAIiB,SAAS,KAAK,CAAlB,EAAqB;AACnB;AACA3B,UAAAA,QAAQ,CAAC,YAAY;AACnB;AACA;AACA;AACA,gBAAIqB,QAAQ,IAAI,CAAC1B,WAAW,CAACwB,KAAZ,CAAkBpB,WAAlB,CAAjB,EAAiD;AAC/CR,cAAAA,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,IAAsDA,aAAa,CAACK,KAAD,EAAQ,KAAR,CAAnE;AACD;AACF,WAPO,CAAR;AAQA,iBAAO,IAAP;AACD;;AACD,eAAO,CAACc,KAAK,GAAG,CAAT,EAAYd,KAAZ,CAAP;AACD,OApBD;AAqBD,KAtBD;AAuBD,GAtC2B,EAsCzB,CAACG,WAAD,CAtCyB,CAA5B;AAuCA,SAAOqB,YAAP;AACD","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { pathKey } from \"../Cache\";\nimport StyleContext from \"../StyleContext\";\nimport useCompatibleInsertionEffect from \"./useCompatibleInsertionEffect\";\nimport useEffectCleanupRegister from \"./useEffectCleanupRegister\";\nimport useHMR from \"./useHMR\";\nexport default function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove,\n// Add additional effect trigger by `useInsertionEffect`\nonCacheEffect) {\n  var _React$useContext = React.useContext(StyleContext),\n    globalCache = _React$useContext.cache;\n  var fullPath = [prefix].concat(_toConsumableArray(keyPath));\n  var fullPathStr = pathKey(fullPath);\n  var register = useEffectCleanupRegister([fullPathStr]);\n  var HMRUpdate = useHMR();\n  var buildCache = function buildCache(updater) {\n    globalCache.opUpdate(fullPathStr, function (prevCache) {\n      var _ref = prevCache || [undefined, undefined],\n        _ref2 = _slicedToArray(_ref, 2),\n        _ref2$ = _ref2[0],\n        times = _ref2$ === void 0 ? 0 : _ref2$,\n        cache = _ref2[1];\n\n      // HMR should always ignore cache since developer may change it\n      var tmpCache = cache;\n      if (process.env.NODE_ENV !== 'production' && cache && HMRUpdate) {\n        onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(tmpCache, HMRUpdate);\n        tmpCache = null;\n      }\n      var mergedCache = tmpCache || cacheFn();\n      var data = [times, mergedCache];\n\n      // Call updater if need additional logic\n      return updater ? updater(data) : data;\n    });\n  };\n\n  // Create cache\n  React.useMemo(function () {\n    buildCache();\n  }, /* eslint-disable react-hooks/exhaustive-deps */\n  [fullPathStr]\n  /* eslint-enable */);\n\n  var cacheEntity = globalCache.opGet(fullPathStr);\n\n  // HMR clean the cache but not trigger `useMemo` again\n  // Let's fallback of this\n  // ref https://github.com/ant-design/cssinjs/issues/127\n  if (process.env.NODE_ENV !== 'production' && !cacheEntity) {\n    buildCache();\n    cacheEntity = globalCache.opGet(fullPathStr);\n  }\n  var cacheContent = cacheEntity[1];\n\n  // Remove if no need anymore\n  useCompatibleInsertionEffect(function () {\n    onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);\n  }, function (polyfill) {\n    // It's bad to call build again in effect.\n    // But we have to do this since StrictMode will call effect twice\n    // which will clear cache on the first time.\n    buildCache(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n        times = _ref4[0],\n        cache = _ref4[1];\n      if (polyfill && times === 0) {\n        onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);\n      }\n      return [times + 1, cache];\n    });\n    return function () {\n      globalCache.opUpdate(fullPathStr, function (prevCache) {\n        var _ref5 = prevCache || [],\n          _ref6 = _slicedToArray(_ref5, 2),\n          _ref6$ = _ref6[0],\n          times = _ref6$ === void 0 ? 0 : _ref6$,\n          cache = _ref6[1];\n        var nextCount = times - 1;\n        if (nextCount === 0) {\n          // Always remove styles in useEffect callback\n          register(function () {\n            // With polyfill, registered callback will always be called synchronously\n            // But without polyfill, it will be called in effect clean up,\n            // And by that time this cache is cleaned up.\n            if (polyfill || !globalCache.opGet(fullPathStr)) {\n              onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(cache, false);\n            }\n          });\n          return null;\n        }\n        return [times - 1, cache];\n      });\n    };\n  }, [fullPathStr]);\n  return cacheContent;\n}"]},"metadata":{},"sourceType":"module"}