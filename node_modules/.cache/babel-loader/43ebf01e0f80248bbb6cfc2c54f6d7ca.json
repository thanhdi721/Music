{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"children\"];\n/* eslint-disable no-lonely-if */\n\n/**\n * Legacy code. Should avoid to use if you are new to import these code.\n */\n\nimport warning from \"rc-util/es/warning\";\nimport React from 'react';\nimport TreeNode from \"./TreeNode\";\nimport getEntity from \"./utils/keyUtil\";\nexport { getPosition, isTreeNode } from \"./utils/treeUtil\";\nexport function arrDel(list, value) {\n  if (!list) return [];\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n\n  return clone;\n}\nexport function arrAdd(list, value) {\n  var clone = (list || []).slice();\n\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n\n  return clone;\n}\nexport function posToArr(pos) {\n  return pos.split('-');\n}\nexport function getDragChildrenKeys(dragNodeKey, keyEntities) {\n  // not contains self\n  // self for left or right drag\n  var dragChildrenKeys = [];\n  var entity = getEntity(keyEntities, dragNodeKey);\n\n  function dig() {\n    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    list.forEach(function (_ref) {\n      var key = _ref.key,\n          children = _ref.children;\n      dragChildrenKeys.push(key);\n      dig(children);\n    });\n  }\n\n  dig(entity.children);\n  return dragChildrenKeys;\n}\nexport function isLastChild(treeNodeEntity) {\n  if (treeNodeEntity.parent) {\n    var posArr = posToArr(treeNodeEntity.pos);\n    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;\n  }\n\n  return false;\n}\nexport function isFirstChild(treeNodeEntity) {\n  var posArr = posToArr(treeNodeEntity.pos);\n  return Number(posArr[posArr.length - 1]) === 0;\n} // Only used when drag, not affect SSR.\n\nexport function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {\n  var _abstractDropNodeEnti;\n\n  var clientX = event.clientX,\n      clientY = event.clientY;\n\n  var _getBoundingClientRec = event.target.getBoundingClientRect(),\n      top = _getBoundingClientRec.top,\n      height = _getBoundingClientRec.height; // optional chain for testing\n\n\n  var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);\n  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent; // Filter the expanded keys to exclude the node that not has children currently (like async nodes).\n\n  var filteredExpandKeys = expandKeys.filter(function (key) {\n    var _keyEntities$key;\n\n    return (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.children) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key.length;\n  }); // find abstract drop node by horizontal offset\n\n  var abstractDropNodeEntity = getEntity(keyEntities, targetNode.props.eventKey);\n\n  if (clientY < top + height / 2) {\n    // first half, set abstract drop node to previous node\n    var nodeIndex = flattenedNodes.findIndex(function (flattenedNode) {\n      return flattenedNode.key === abstractDropNodeEntity.key;\n    });\n    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;\n    var prevNodeKey = flattenedNodes[prevNodeIndex].key;\n    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);\n  }\n\n  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;\n  var abstractDragOverEntity = abstractDropNodeEntity;\n  var dragOverNodeKey = abstractDropNodeEntity.key;\n  var dropPosition = 0;\n  var dropLevelOffset = 0; // Only allow cross level drop when dragging on a non-expanded node\n\n  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {\n    for (var i = 0; i < rawDropLevelOffset; i += 1) {\n      if (isLastChild(abstractDropNodeEntity)) {\n        abstractDropNodeEntity = abstractDropNodeEntity.parent;\n        dropLevelOffset += 1;\n      } else {\n        break;\n      }\n    }\n  }\n\n  var abstractDragDataNode = dragNode.props.data;\n  var abstractDropDataNode = abstractDropNodeEntity.node;\n  var dropAllowed = true;\n\n  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({\n    dragNode: abstractDragDataNode,\n    dropNode: abstractDropDataNode,\n    dropPosition: -1\n  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {\n    // first half of first node in first level\n    dropPosition = -1;\n  } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {\n    // drop on expanded node\n    // only allow drop inside\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 0\n    })) {\n      dropPosition = 0;\n    } else {\n      dropAllowed = false;\n    }\n  } else if (dropLevelOffset === 0) {\n    if (rawDropLevelOffset > -1.5) {\n      // | Node     | <- abstractDropNode\n      // | -^-===== | <- mousePosition\n      // 1. try drop after\n      // 2. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    } else {\n      // | Node     | <- abstractDropNode\n      // | ---==^== | <- mousePosition\n      // whether it has children or doesn't has children\n      // always\n      // 1. try drop inside\n      // 2. try drop after\n      // 3. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 0\n      })) {\n        dropPosition = 0;\n      } else if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    }\n  } else {\n    // | Node1 | <- abstractDropNode\n    //      |  Node2  |\n    // --^--|----=====| <- mousePosition\n    // 1. try insert after Node1\n    // 2. do not allow drop\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 1\n    })) {\n      dropPosition = 1;\n    } else {\n      dropAllowed = false;\n    }\n  }\n\n  return {\n    dropPosition: dropPosition,\n    dropLevelOffset: dropLevelOffset,\n    dropTargetKey: abstractDropNodeEntity.key,\n    dropTargetPos: abstractDropNodeEntity.pos,\n    dragOverNodeKey: dragOverNodeKey,\n    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,\n    dropAllowed: dropAllowed\n  };\n}\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\n\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n\n  return selectedKeys;\n}\n\nvar internalProcessProps = function internalProcessProps(props) {\n  return props;\n};\n\nexport function convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n\n  var _ref2 = processor || {},\n      _ref2$processProps = _ref2.processProps,\n      processProps = _ref2$processProps === void 0 ? internalProcessProps : _ref2$processProps;\n\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_ref3) {\n    var children = _ref3.children,\n        props = _objectWithoutProperties(_ref3, _excluded);\n\n    var childrenNodes = convertDataToTree(children, processor);\n    return /*#__PURE__*/React.createElement(TreeNode, _extends({\n      key: props.key\n    }, processProps(props)), childrenNodes);\n  });\n}\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\n\nexport function parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  } // Convert keys to object format\n\n\n  var keyProps;\n\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (_typeof(keys) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n\n  return keyProps;\n}\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\n\nexport function conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = new Set();\n\n  function conductUp(key) {\n    if (expandedKeys.has(key)) return;\n    var entity = getEntity(keyEntities, key);\n    if (!entity) return;\n    expandedKeys.add(key);\n    var parent = entity.parent,\n        node = entity.node;\n    if (node.disabled) return;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n  return _toConsumableArray(expandedKeys);\n}","map":{"version":3,"sources":["D:/WED/SpotifyProject-master/node_modules/rc-tree/es/util.js"],"names":["_toConsumableArray","_typeof","_extends","_objectWithoutProperties","_excluded","warning","React","TreeNode","getEntity","getPosition","isTreeNode","arrDel","list","value","clone","slice","index","indexOf","splice","arrAdd","push","posToArr","pos","split","getDragChildrenKeys","dragNodeKey","keyEntities","dragChildrenKeys","entity","dig","arguments","length","undefined","forEach","_ref","key","children","isLastChild","treeNodeEntity","parent","posArr","Number","isFirstChild","calcDropPosition","event","dragNode","targetNode","indent","startMousePosition","allowDrop","flattenedNodes","expandKeys","direction","_abstractDropNodeEnti","clientX","clientY","_getBoundingClientRec","target","getBoundingClientRect","top","height","horizontalMouseOffset","x","rawDropLevelOffset","filteredExpandKeys","filter","_keyEntities$key","abstractDropNodeEntity","props","eventKey","nodeIndex","findIndex","flattenedNode","prevNodeIndex","prevNodeKey","initialAbstractDropNodeKey","abstractDragOverEntity","dragOverNodeKey","dropPosition","dropLevelOffset","includes","i","abstractDragDataNode","data","abstractDropDataNode","node","dropAllowed","level","dropNode","dropTargetKey","dropTargetPos","dropContainerKey","calcSelectedKeys","selectedKeys","multiple","internalProcessProps","convertDataToTree","treeData","processor","_ref2","_ref2$processProps","processProps","Array","isArray","map","_ref3","childrenNodes","createElement","parseCheckedKeys","keys","keyProps","checkedKeys","halfCheckedKeys","checked","halfChecked","conductExpandParent","keyList","expandedKeys","Set","conductUp","has","add","disabled"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"children\"];\n/* eslint-disable no-lonely-if */\n/**\n * Legacy code. Should avoid to use if you are new to import these code.\n */\n\nimport warning from \"rc-util/es/warning\";\nimport React from 'react';\nimport TreeNode from \"./TreeNode\";\nimport getEntity from \"./utils/keyUtil\";\nexport { getPosition, isTreeNode } from \"./utils/treeUtil\";\nexport function arrDel(list, value) {\n  if (!list) return [];\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n  return clone;\n}\nexport function arrAdd(list, value) {\n  var clone = (list || []).slice();\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n  return clone;\n}\nexport function posToArr(pos) {\n  return pos.split('-');\n}\nexport function getDragChildrenKeys(dragNodeKey, keyEntities) {\n  // not contains self\n  // self for left or right drag\n  var dragChildrenKeys = [];\n  var entity = getEntity(keyEntities, dragNodeKey);\n  function dig() {\n    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    list.forEach(function (_ref) {\n      var key = _ref.key,\n        children = _ref.children;\n      dragChildrenKeys.push(key);\n      dig(children);\n    });\n  }\n  dig(entity.children);\n  return dragChildrenKeys;\n}\nexport function isLastChild(treeNodeEntity) {\n  if (treeNodeEntity.parent) {\n    var posArr = posToArr(treeNodeEntity.pos);\n    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;\n  }\n  return false;\n}\nexport function isFirstChild(treeNodeEntity) {\n  var posArr = posToArr(treeNodeEntity.pos);\n  return Number(posArr[posArr.length - 1]) === 0;\n}\n\n// Only used when drag, not affect SSR.\nexport function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {\n  var _abstractDropNodeEnti;\n  var clientX = event.clientX,\n    clientY = event.clientY;\n  var _getBoundingClientRec = event.target.getBoundingClientRect(),\n    top = _getBoundingClientRec.top,\n    height = _getBoundingClientRec.height;\n  // optional chain for testing\n  var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);\n  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;\n\n  // Filter the expanded keys to exclude the node that not has children currently (like async nodes).\n  var filteredExpandKeys = expandKeys.filter(function (key) {\n    var _keyEntities$key;\n    return (_keyEntities$key = keyEntities[key]) === null || _keyEntities$key === void 0 || (_keyEntities$key = _keyEntities$key.children) === null || _keyEntities$key === void 0 ? void 0 : _keyEntities$key.length;\n  });\n\n  // find abstract drop node by horizontal offset\n  var abstractDropNodeEntity = getEntity(keyEntities, targetNode.props.eventKey);\n  if (clientY < top + height / 2) {\n    // first half, set abstract drop node to previous node\n    var nodeIndex = flattenedNodes.findIndex(function (flattenedNode) {\n      return flattenedNode.key === abstractDropNodeEntity.key;\n    });\n    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;\n    var prevNodeKey = flattenedNodes[prevNodeIndex].key;\n    abstractDropNodeEntity = getEntity(keyEntities, prevNodeKey);\n  }\n  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;\n  var abstractDragOverEntity = abstractDropNodeEntity;\n  var dragOverNodeKey = abstractDropNodeEntity.key;\n  var dropPosition = 0;\n  var dropLevelOffset = 0;\n\n  // Only allow cross level drop when dragging on a non-expanded node\n  if (!filteredExpandKeys.includes(initialAbstractDropNodeKey)) {\n    for (var i = 0; i < rawDropLevelOffset; i += 1) {\n      if (isLastChild(abstractDropNodeEntity)) {\n        abstractDropNodeEntity = abstractDropNodeEntity.parent;\n        dropLevelOffset += 1;\n      } else {\n        break;\n      }\n    }\n  }\n  var abstractDragDataNode = dragNode.props.data;\n  var abstractDropDataNode = abstractDropNodeEntity.node;\n  var dropAllowed = true;\n  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({\n    dragNode: abstractDragDataNode,\n    dropNode: abstractDropDataNode,\n    dropPosition: -1\n  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {\n    // first half of first node in first level\n    dropPosition = -1;\n  } else if ((abstractDragOverEntity.children || []).length && filteredExpandKeys.includes(dragOverNodeKey)) {\n    // drop on expanded node\n    // only allow drop inside\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 0\n    })) {\n      dropPosition = 0;\n    } else {\n      dropAllowed = false;\n    }\n  } else if (dropLevelOffset === 0) {\n    if (rawDropLevelOffset > -1.5) {\n      // | Node     | <- abstractDropNode\n      // | -^-===== | <- mousePosition\n      // 1. try drop after\n      // 2. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    } else {\n      // | Node     | <- abstractDropNode\n      // | ---==^== | <- mousePosition\n      // whether it has children or doesn't has children\n      // always\n      // 1. try drop inside\n      // 2. try drop after\n      // 3. do not allow drop\n      if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 0\n      })) {\n        dropPosition = 0;\n      } else if (allowDrop({\n        dragNode: abstractDragDataNode,\n        dropNode: abstractDropDataNode,\n        dropPosition: 1\n      })) {\n        dropPosition = 1;\n      } else {\n        dropAllowed = false;\n      }\n    }\n  } else {\n    // | Node1 | <- abstractDropNode\n    //      |  Node2  |\n    // --^--|----=====| <- mousePosition\n    // 1. try insert after Node1\n    // 2. do not allow drop\n    if (allowDrop({\n      dragNode: abstractDragDataNode,\n      dropNode: abstractDropDataNode,\n      dropPosition: 1\n    })) {\n      dropPosition = 1;\n    } else {\n      dropAllowed = false;\n    }\n  }\n  return {\n    dropPosition: dropPosition,\n    dropLevelOffset: dropLevelOffset,\n    dropTargetKey: abstractDropNodeEntity.key,\n    dropTargetPos: abstractDropNodeEntity.pos,\n    dragOverNodeKey: dragOverNodeKey,\n    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,\n    dropAllowed: dropAllowed\n  };\n}\n\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\nexport function calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  var multiple = props.multiple;\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n  return selectedKeys;\n}\nvar internalProcessProps = function internalProcessProps(props) {\n  return props;\n};\nexport function convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n  var _ref2 = processor || {},\n    _ref2$processProps = _ref2.processProps,\n    processProps = _ref2$processProps === void 0 ? internalProcessProps : _ref2$processProps;\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_ref3) {\n    var children = _ref3.children,\n      props = _objectWithoutProperties(_ref3, _excluded);\n    var childrenNodes = convertDataToTree(children, processor);\n    return /*#__PURE__*/React.createElement(TreeNode, _extends({\n      key: props.key\n    }, processProps(props)), childrenNodes);\n  });\n}\n\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\nexport function parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  }\n\n  // Convert keys to object format\n  var keyProps;\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (_typeof(keys) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    warning(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n  return keyProps;\n}\n\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\nexport function conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = new Set();\n  function conductUp(key) {\n    if (expandedKeys.has(key)) return;\n    var entity = getEntity(keyEntities, key);\n    if (!entity) return;\n    expandedKeys.add(key);\n    var parent = entity.parent,\n      node = entity.node;\n    if (node.disabled) return;\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n  return _toConsumableArray(expandedKeys);\n}"]},"metadata":{},"sourceType":"module"}