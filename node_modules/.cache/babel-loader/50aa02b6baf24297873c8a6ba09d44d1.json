{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\n\nfunction isPointsEq() {\n  var a1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var a2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var isAlignPoint = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\n\nexport function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  var points = align.points;\n  var placements = Object.keys(builtinPlacements);\n\n  for (var i = 0; i < placements.length; i += 1) {\n    var _builtinPlacements$pl;\n\n    var placement = placements[i];\n\n    if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {\n      return \"\".concat(prefixCls, \"-placement-\").concat(placement);\n    }\n  }\n\n  return '';\n}\n/** @deprecated We should not use this if we can refactor all deps */\n\nexport function getMotion(prefixCls, motion, animation, transitionName) {\n  if (motion) {\n    return motion;\n  }\n\n  if (animation) {\n    return {\n      motionName: \"\".concat(prefixCls, \"-\").concat(animation)\n    };\n  }\n\n  if (transitionName) {\n    return {\n      motionName: transitionName\n    };\n  }\n\n  return null;\n}\nexport function getWin(ele) {\n  return ele.ownerDocument.defaultView;\n}\n/**\n * Get all the scrollable parent elements of the element\n * @param ele       The element to be detected\n * @param areaOnly  Only return the parent which will cut visible area\n */\n\nexport function collectScroller(ele) {\n  var scrollerList = [];\n  var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;\n  var scrollStyle = ['hidden', 'scroll', 'clip', 'auto'];\n\n  while (current) {\n    var _getWin$getComputedSt = getWin(current).getComputedStyle(current),\n        overflowX = _getWin$getComputedSt.overflowX,\n        overflowY = _getWin$getComputedSt.overflowY,\n        overflow = _getWin$getComputedSt.overflow;\n\n    if ([overflowX, overflowY, overflow].some(function (o) {\n      return scrollStyle.includes(o);\n    })) {\n      scrollerList.push(current);\n    }\n\n    current = current.parentElement;\n  }\n\n  return scrollerList;\n}\nexport function toNum(num) {\n  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return Number.isNaN(num) ? defaultValue : num;\n}\n\nfunction getPxValue(val) {\n  return toNum(parseFloat(val), 0);\n}\n/**\n *\n *\n *  **************************************\n *  *              Border                *\n *  *     **************************     *\n *  *     *                  *     *     *\n *  *  B  *                  *  S  *  B  *\n *  *  o  *                  *  c  *  o  *\n *  *  r  *      Content     *  r  *  r  *\n *  *  d  *                  *  o  *  d  *\n *  *  e  *                  *  l  *  e  *\n *  *  r  ********************  l  *  r  *\n *  *     *        Scroll          *     *\n *  *     **************************     *\n *  *              Border                *\n *  **************************************\n *\n */\n\n/**\n * Get visible area of element\n */\n\n\nexport function getVisibleArea(initArea, scrollerList) {\n  var visibleArea = _objectSpread({}, initArea);\n\n  (scrollerList || []).forEach(function (ele) {\n    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {\n      return;\n    } // Skip if static position which will not affect visible area\n\n\n    var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele),\n        overflow = _getWin$getComputedSt2.overflow,\n        overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin,\n        borderTopWidth = _getWin$getComputedSt2.borderTopWidth,\n        borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth,\n        borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth,\n        borderRightWidth = _getWin$getComputedSt2.borderRightWidth;\n\n    var eleRect = ele.getBoundingClientRect();\n    var eleOutHeight = ele.offsetHeight,\n        eleInnerHeight = ele.clientHeight,\n        eleOutWidth = ele.offsetWidth,\n        eleInnerWidth = ele.clientWidth;\n    var borderTopNum = getPxValue(borderTopWidth);\n    var borderBottomNum = getPxValue(borderBottomWidth);\n    var borderLeftNum = getPxValue(borderLeftWidth);\n    var borderRightNum = getPxValue(borderRightWidth);\n    var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n    var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000); // Original visible area\n\n    var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;\n    var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY; // Cut border size\n\n    var scaledBorderTopWidth = borderTopNum * scaleY;\n    var scaledBorderBottomWidth = borderBottomNum * scaleY;\n    var scaledBorderLeftWidth = borderLeftNum * scaleX;\n    var scaledBorderRightWidth = borderRightNum * scaleX; // Clip margin\n\n    var clipMarginWidth = 0;\n    var clipMarginHeight = 0;\n\n    if (overflow === 'clip') {\n      var clipNum = getPxValue(overflowClipMargin);\n      clipMarginWidth = clipNum * scaleX;\n      clipMarginHeight = clipNum * scaleY;\n    } // Region\n\n\n    var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;\n    var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;\n    var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;\n    var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;\n    visibleArea.left = Math.max(visibleArea.left, eleLeft);\n    visibleArea.top = Math.max(visibleArea.top, eleTop);\n    visibleArea.right = Math.min(visibleArea.right, eleRight);\n    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n  });\n  return visibleArea;\n}","map":{"version":3,"sources":["D:/WED/SpotifyProject-master/node_modules/@rc-component/trigger/es/util.js"],"names":["_objectSpread","isPointsEq","a1","arguments","length","undefined","a2","isAlignPoint","getAlignPopupClassName","builtinPlacements","prefixCls","align","points","placements","Object","keys","i","_builtinPlacements$pl","placement","concat","getMotion","motion","animation","transitionName","motionName","getWin","ele","ownerDocument","defaultView","collectScroller","scrollerList","current","parentElement","scrollStyle","_getWin$getComputedSt","getComputedStyle","overflowX","overflowY","overflow","some","o","includes","push","toNum","num","defaultValue","Number","isNaN","getPxValue","val","parseFloat","getVisibleArea","initArea","visibleArea","forEach","HTMLBodyElement","HTMLHtmlElement","_getWin$getComputedSt2","overflowClipMargin","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","eleRect","getBoundingClientRect","eleOutHeight","offsetHeight","eleInnerHeight","clientHeight","eleOutWidth","offsetWidth","eleInnerWidth","clientWidth","borderTopNum","borderBottomNum","borderLeftNum","borderRightNum","scaleX","Math","round","width","scaleY","height","eleScrollWidth","eleScrollHeight","scaledBorderTopWidth","scaledBorderBottomWidth","scaledBorderLeftWidth","scaledBorderRightWidth","clipMarginWidth","clipMarginHeight","clipNum","eleLeft","x","eleTop","y","eleRight","eleBottom","left","max","top","right","min","bottom"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nfunction isPointsEq() {\n  var a1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var a2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var isAlignPoint = arguments.length > 2 ? arguments[2] : undefined;\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\nexport function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  var points = align.points;\n  var placements = Object.keys(builtinPlacements);\n  for (var i = 0; i < placements.length; i += 1) {\n    var _builtinPlacements$pl;\n    var placement = placements[i];\n    if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {\n      return \"\".concat(prefixCls, \"-placement-\").concat(placement);\n    }\n  }\n  return '';\n}\n\n/** @deprecated We should not use this if we can refactor all deps */\nexport function getMotion(prefixCls, motion, animation, transitionName) {\n  if (motion) {\n    return motion;\n  }\n  if (animation) {\n    return {\n      motionName: \"\".concat(prefixCls, \"-\").concat(animation)\n    };\n  }\n  if (transitionName) {\n    return {\n      motionName: transitionName\n    };\n  }\n  return null;\n}\nexport function getWin(ele) {\n  return ele.ownerDocument.defaultView;\n}\n\n/**\n * Get all the scrollable parent elements of the element\n * @param ele       The element to be detected\n * @param areaOnly  Only return the parent which will cut visible area\n */\nexport function collectScroller(ele) {\n  var scrollerList = [];\n  var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;\n  var scrollStyle = ['hidden', 'scroll', 'clip', 'auto'];\n  while (current) {\n    var _getWin$getComputedSt = getWin(current).getComputedStyle(current),\n      overflowX = _getWin$getComputedSt.overflowX,\n      overflowY = _getWin$getComputedSt.overflowY,\n      overflow = _getWin$getComputedSt.overflow;\n    if ([overflowX, overflowY, overflow].some(function (o) {\n      return scrollStyle.includes(o);\n    })) {\n      scrollerList.push(current);\n    }\n    current = current.parentElement;\n  }\n  return scrollerList;\n}\nexport function toNum(num) {\n  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return Number.isNaN(num) ? defaultValue : num;\n}\nfunction getPxValue(val) {\n  return toNum(parseFloat(val), 0);\n}\n/**\n *\n *\n *  **************************************\n *  *              Border                *\n *  *     **************************     *\n *  *     *                  *     *     *\n *  *  B  *                  *  S  *  B  *\n *  *  o  *                  *  c  *  o  *\n *  *  r  *      Content     *  r  *  r  *\n *  *  d  *                  *  o  *  d  *\n *  *  e  *                  *  l  *  e  *\n *  *  r  ********************  l  *  r  *\n *  *     *        Scroll          *     *\n *  *     **************************     *\n *  *              Border                *\n *  **************************************\n *\n */\n/**\n * Get visible area of element\n */\nexport function getVisibleArea(initArea, scrollerList) {\n  var visibleArea = _objectSpread({}, initArea);\n  (scrollerList || []).forEach(function (ele) {\n    if (ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement) {\n      return;\n    }\n\n    // Skip if static position which will not affect visible area\n    var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele),\n      overflow = _getWin$getComputedSt2.overflow,\n      overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin,\n      borderTopWidth = _getWin$getComputedSt2.borderTopWidth,\n      borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth,\n      borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth,\n      borderRightWidth = _getWin$getComputedSt2.borderRightWidth;\n    var eleRect = ele.getBoundingClientRect();\n    var eleOutHeight = ele.offsetHeight,\n      eleInnerHeight = ele.clientHeight,\n      eleOutWidth = ele.offsetWidth,\n      eleInnerWidth = ele.clientWidth;\n    var borderTopNum = getPxValue(borderTopWidth);\n    var borderBottomNum = getPxValue(borderBottomWidth);\n    var borderLeftNum = getPxValue(borderLeftWidth);\n    var borderRightNum = getPxValue(borderRightWidth);\n    var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n    var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n\n    // Original visible area\n    var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;\n    var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;\n\n    // Cut border size\n    var scaledBorderTopWidth = borderTopNum * scaleY;\n    var scaledBorderBottomWidth = borderBottomNum * scaleY;\n    var scaledBorderLeftWidth = borderLeftNum * scaleX;\n    var scaledBorderRightWidth = borderRightNum * scaleX;\n\n    // Clip margin\n    var clipMarginWidth = 0;\n    var clipMarginHeight = 0;\n    if (overflow === 'clip') {\n      var clipNum = getPxValue(overflowClipMargin);\n      clipMarginWidth = clipNum * scaleX;\n      clipMarginHeight = clipNum * scaleY;\n    }\n\n    // Region\n    var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;\n    var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;\n    var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;\n    var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;\n    visibleArea.left = Math.max(visibleArea.left, eleLeft);\n    visibleArea.top = Math.max(visibleArea.top, eleTop);\n    visibleArea.right = Math.min(visibleArea.right, eleRight);\n    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n  });\n  return visibleArea;\n}"]},"metadata":{},"sourceType":"module"}